# 转变思维

学习一门新的编程语言一点都不难，你只要知道怎么把熟悉的概念用新的语法表达出来就行了。
与之相比，学习一种新的范式是困难的————我们必须学会为熟悉的问题找到新的解答方法。

换用 Scala, Clojure 之类的函数式编程语言并不是写出函数式代码的必要条件，转变我们看待问题的角度才是必不可少的。

函数式编程希望在算法编写上给予程序员帮助，一方面程序员得以在更高地抽象层次上工作，另一方面运行时也有了执行复杂优化的自由空间。开发者从中获得的好处体现在更低的复发性和更高地性能，这点与垃圾收集相同，不过，函数式编程对个人的影响更直接，因为它改变的是你的解答思路。

命令式编程是按照”程序是一系列改变状态的命令“来建模的一种编程风格。

函数式编程将程序描述为表达式和变换，以数学方程的形式建立模型，并且尽量避免可变的状态。

向函数式思维靠拢，意味着我们逐渐学会何时何地应该求助于这些更高层次地抽象，不要再一头扎到实现细节里去。

学会用更高层次地抽象来思考有什么好处？
首先，会促使我们换一种角度去归类问题，看到问题的共性。
其次，让运行时有更大的余地去做智能的优化。有时候，在不改变最终输出的前提下，调整一下作业的先后次序会更有效（例如减少了需要处理的条目）。
第三，让埋头于实现细节的开发者看到原本视野之外的一些解决方法。

多从结果着眼，少纠结具体的步骤。

不要再让那些迭代，变换，化约如何进行的低层次细节占据你的思维，多想想哪些问题其实可以归结为这几样基本操作的排列组合吧。

具有普遍意义的基本构造单元：
筛选(filter);  
映射(map);  
折叠/化约：foldLeft 和 reduce 都是 catamorphism 这种范畴论的态射概念具体应用到列表操纵上面的变体，catamorphism 是对列表”折叠“(fold) 概念的推广。

reduce 和 fold 操作在功能上大致重合，但根据具体的编程语言而有微妙的区别。
两者都用一个累加量(accumulator) 来”收集“集合元素。
reduce 函数一般在需要为累积量设定一个初始值的时候使用，而 fold 起始的时候累积量是空的。
函数在操作集合的时候可以有不同的次序，这点会体现在相应的函数命名上（如 foldLeft 和 foldRight)。

学习函数式编程，或者任何一种新范式都有一个很大的挑战，那就是在掌握新的构造单元之后，还要善于从问题里“发现”它们的身影，从而抓住解答的脉络。
函数式编程不会用很多抽象，但每个抽象的泛化程度都很高（特化的方面通过高阶函数注入）。
函数式编程以参数传递和函数的复合作为主要的表现手段，我们不需要掌握太多作为“不确定因素”存在的其他语言构造之间的交互规则，这一点对于我们的学习是有利的。

函数的同义异名问题

筛选
筛选操作与查找(find)函数的关系很密切，查找函数返回的是集合中第一个符合条件的元素。

映射
