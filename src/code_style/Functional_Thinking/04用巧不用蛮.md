# 用巧不用蛮

我们转换范式的收获，表现在费更少的力气完成更多的事情。
很多函数式编程构造的目的只有一个：从频繁出现的场景中消灭掉烦人的实现细节。

我们要讨论函数式语言的两种常见特性：记忆(memoization) 和缓求值(laziness)

## 记忆

这种缓存函数计算结果的做法，是计算机科学里一种典型的折中方案：用更多的内存（我们一般不缺内存）去换取长期来说更高的效率。

只有纯（pure）函数才可以适用缓存技术。
纯函数是没有副作用的函数：它不引用其他值可变的类字段，除返回值之外不设置其他的变量，其结果完全由输入参数决定。
很显然，只有在函数对同样一组参数总是返回相同结果的前提下，我们才可以放心地使用缓存起来的结果。

缓存可以提高性能，但缓存有代价；它提高了代码的非本质复杂性和维护负担。

引入记忆
函数式编程费了很大的力气来遏制不确定因素，并为此在运行时里内建了多种重用机制。
“记忆”是其中一种特性，它作为编程语言的固有设施，自动地缓存重复出现的函数返回值。

Groovy 语言记忆一个函数的办法是，先将要记忆的函数定义成闭包，然后对该闭包执行 memoize() 方法来获得一个新函数，以后我们调用这个新函数的时候，其结果就会被缓存起来。

在命令式的思路下，开发者是代码的主人（以及一切责任的承担者）。而函数式语言的思路是，为了操纵一些标准的构造，我们来制作一些通用的机件，有时候还在机件上设置若干调节旋钮（也就是函数的不同变体和参数的不同组合）。函数式语言的基本元素，因此函数层面上的优化会附带产生功能的提升。

语言设计者实现出来的机制总是比开发者自己做的效率更高，因为它们可以不受语言本身的限制。

手工建立缓存的工作不算复杂，但它给代码增加了状态的影响和额外的复杂性。而借助函数式语言的特性，例如记忆，我们可以在函数的级别上完成缓存工作，只需要微不足道的改动，就能取得比命令式做法更好的效果。在函数式编程消除了不确定因素之后，我们得以专注解决真正的问题。

大多数函数式语言要么直接提供了记忆特性，要么实现起来极其轻松。
例如 Clojure 语言就内建了记忆特性，我们可以通过语言内建的(memoize)函数为任意函数增加记忆能力。
例如想记忆现有的一个（hash）函数，我们只要写成(memoize(hash "homer"))就可以得到该函数的缓存版本。

请保证所有被记忆的函数：没有副作用，不依赖任何外部信息

## 缓求值

缓求值（lazy evaluation）是函数式编程语言常见的一种特性，指尽可能地推迟求解表达式。
缓求值的集合不会预先算好所有的元素，而是在用到的时候才落实，这样做有几个好处。
第一，昂贵的运算只有到了绝对必要的时候才执行。
第二，我们可以建立无限大的集合，只要一直接到请求，就一直送出元素。
第三，按缓求值的方式来使用映射，筛选等函数式概念，可以产生更高效的代码。

编程语言的一项性质：严格求值(strict)的，和非严格求值(non-strict)(也叫缓求值， lazy）的.

//演示“非严格求值”的伪代码
`print length([2+1, 3*2, 1/0, 5-4])`
如果是严格求值的，会因为 `1/0` 而抛出异常，
如果是非严格求值的，会打印出 4
