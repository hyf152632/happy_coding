# 权责让渡

函数式思维的好处之：一一，是能够将低层次细节（如垃圾收集）的控制权移交给运行时，从
而消弭了一大批注定会发生的程序错误。开发者们可以一一边熟视无睹地享受着最基本的抽
象，比如内存，一边却会对更高层次的抽象感觉突儿。然而不管层次高低，抽象的目的总
是一样的：让开发者从繁琐的运作细节里解脱出来，去解答问题中非重复性的那些方面。

在函数式语言中，向语言和运行时让渡控制权的五种途径。

1. 迭代让位于高阶函数

这笔“交易”的得失很清楚：如果能够用高阶函数把希望执行的操作表达出来，语言将会把操作安排得更高效，甚至只要增加一行 par 修饰，就能够让操作并行化。

这样说并不等于开发者应该抛开所有的责任，不去理解低层次抽象的来龙去脉。在很多情
况下，我们使用一个抽象，比如 Stream 的时候，必须清楚可能产生的连带后果。当你掌握了背后的原理，才能把力量用在最正确的地方。

理解掌握的抽象层次永远要比日常使用的抽象层次更深一层。

程序员的工作效率依赖于抽象层，好比没有人会直接翻弄硬盘上或 0 或 1 的磁记录来给计
算机编程。抽象隐藏了繁杂的细节，只是有时候会连同重要的考虑因素一一起隐藏掉。

2. 闭包

闭包（closure）是所有函数式语言都具备的一项平常特性，可是相关的论述却常常充斥着
晦涩乃至神秘的字眼。所谓闭包，实际上是一一种特殊的函数，它在暗地里绑定了函数内部
引用的所有变量。换句话说，这种函数（或方法）把它引用的所有东西都放在一个上下文
里“包”了起来。

闭包在这里表现出来的函数式思维就是“让运行时去管理状态"。比起自己硬着头皮去处理字段创建、呵护状态（包括经受多线程环境的严酷考验）这些繁琐的事务，还不如交出对状态的控制权，让语言和框架悄悄在背后帮我们管理好。

闭包还是推迟执行原则的绝佳样板。我们把代码绑定到闭包之后，可以推迟到适当的时机
再执行闭包。这个特点在很多场合都能发挥作用。例如必要的变量和函数可能并不在定义
时的作用域里，要到执行的时候才准备好。那么我们把执行上下文放在闭包里保留起来，
就可以等到正确的时机再完成执行。
命令式语言围绕状态来建立编程模型，参数传递是其典型特征。闭包作为一种对行为的建
模手段，让我们把代码和上下文同时封装在单一一结构，也就是闭包本身里面，像传统数据
结构一样可以传递到其他位置，然后在恰当的时间和地点完成执行。

3. 柯里化和函数的部分施用

乍看起来，柯里化和部分施用的使用效果是一一样的。两者都可以创建有一部分预设参数值的函数。

柯里化指的是从一一个多参数函数变成一一连串单参数函数的变换。它描述的是变换的过程，不涉及变换之后对函数的调用。调用者可以决定对多少个参数实施变换，余下的部分将衍生为一个参数数目较少的新函数。
部分施用指通过提前代入一部分参数值，使一个多参数函数得以省略部分参数，从而转化
为一个参数数目较少的函数。这种技法叫作“部分施用”，顾名思义，就是让函数先作用
于其中一些参数，经过部分的求解，结果返回一个由余下参数构成签名的函数。

举个例子，函数 process（x，y，z） 完全柯里化之后将变成 process（x）（y）（z）的形式，其
中 process（x）和 process（x）（y）都是单参数的函数。如果只对第一个参数柯里化，那么
process（x）的返回值将是一个单参数的函数，而这个唯一的参数又接受另一个参数的输
人。而部分施用的结果直接是一个减少 了元数的函数。如果在 process（x,y,z）上部分施
用一个参数，那么我们将得到还剩下两个参数的函数： process（y， z）。
这两种技法的区分很重要而且很容易被错误地理解，可是使用中它们】偏偏又经常得到相同
的结果。这里还有更加添乱的事情，Groovy 实现了部分施用也实现了柯里化，但是它把两
者都叫作柯里化。Scala 既有部分施用函数（partially applied function）， 又有名称相近的偏
函数类 PartialFunction，可它们是截然不同的两个概念。

4. 递归

递归，按照维基百科的定义，是“以一种自相似的方式来重复事物的过程”。它也是我们向运行时托付操作细节的一一个例子，而且和函数式编程有着极为密切的联系。以具体的实，践来说，递归是以一种带点计算机科学味道的方式来对一组事物进行迭代，让事物的集合反复对自身调用同样的方法，使集合随着每次迭代不断缩小，同时要始终小心地保证退出
条件的有效性。很多时候，我们的问题核心就是对一个不断变短的列表反复地做同一件事，把递归用在这样的场合，写出来的代码就容易理解。
