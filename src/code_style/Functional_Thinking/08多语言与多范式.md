# 多语言与多范式

多范式的语言赋予了开发者组合、搭配不同范式的余裕，这是多范式语言潜藏的力量。
Java8 以前的旧版 Java 束手束脚令很多开发者着恼，而像 Groovy 这样的语言则拥有包括
元编程和函数式的语言构造在内，丰富得多的编程手段可供驱策。
多范式语言虽然强大，但也要求开发者更注重纪律，才能驾驭好大型的项目。由于语言支
持各式各样的抽象和观念，由不同开发者群体制作出来的库也会呈现明显的差异。我们在
第 6 章已经讨论过，不同范式的基本思路就不一样。举例来说，代码重用在面向对象的世
界里多表现为对结构的重用，而函数式的世界则多以组合和高阶函数作为重用的手段。如
果要为公司设计一套 Customer API，你会选择什么样的风格呢？很多从 Java 语言迁移到
Ruby 语言的开发者都遇到了这个难题，因为 Ruby 是一款兼容并包的多范式语言。
依靠工程纪律来保证所有的开发者都朝着同一一个方向努力，是解决协调问题的一种途径。
单元测试为开发者精确地理解经元编程实现的复杂扩展提供了方便。开发者可以运用“消
费者驱动的契约”等技巧，（以测试的形式）在不同团队之间建立可执行的契约。

上下文抽象与复合型抽象的对比

函数式思维不只体现在项目采用的语言上，它还影响到工具的设计。我在第 6 章说过，复
合是函数式编程领域奉为圭臬的设计原则。现在我想把它推广到 L 具的领域，并对比两
种在编程世界中流行的抽象形态，一。 种是复合型（composable） 抽象，另一 种是上下文型
（contextual）抽象。基于插件的架构可以作为上下文型抽象的代表。开发者可以直接从插
件 API 处继承得到，或者间接透过已有的方法来号令插件 API 提供林林总总的数据结构
和其他有用的上下文。但是为了使用 API，开发者必须首先理解上下文提供的是什么，而
“理解”有时候是十分昂贵的。我询问过开发者在使用编辑器或 IDE 的过程中，会不会经
常对 IDE 本身的行为做一。些较大的、至少不能靠调整设置来完成的改动。结果即使是天
天离不开 IDE 的重度用户也很少做这样的事情，因为扩展 Eclipse 之类的工具必须跨过极
高的知识广】槛。不起眼的改动和完成改动所需的知识、精力之间的落差，让开发者永远地
打消了磨砺工具的念头。上下文型的工具绝不是什么坏事，没有这样的架构设计，就不会
有 Eclipse 和 IntelliJ。。上： 下文型的工具为开发者事先准备了极丰富的基础设施。一 。 旦掌握
Eclipse API 错综复杂的细节，开发者可以获得被 API 封装起来的巨大能量。可是这里面有
一个大大的痛处：怎样封装？

复合型的系统倾向于使用一一些细粒度的部件来组成整体，且这些部件都已准备好以特定方
式相连接。我们可以在 Unix shell 中找到复合型抽象的鲜明范例，在 shell 命令行里，各种
互相独立、五花八门的行为可以串联在一一起创造出新的事物。

上下文型的系统提供了更多扶持性的“脚手架”设施，更完善的预设行为，以及“脚手
架”上承载的上下文智能。可以说，上下文型系统更多地依靠周全的预设功能来缓解开发
者初次使用时的不顺。在这类系统中，继承关系有时候会隐含地带入一些全局性的庞大数
据结构，成为下游派生扩展的巨大包袱。复合型的系统较少隐性的行为，较容易上手，但
倾向于提供细粒度的构造单元，需经过一一定过程才能发挥真正的实力。设计得当的复合型
系统应当在封装的模块内提供窄范围的、局部的上下文。

复合型的构建工具（对时间、复杂度、用途）的适应性要好于上下文型的构建工具。

寄居在语言上的工具往往表现出更强的复合型特性。Ruby 世界的构建工具，Rake（http://
rake.rubyforge.org/），是我最喜欢的专用构建语言，可以用在各种公私项目上（几乎不受项
目本身技术选型的限制）。它是简洁与力量的奇妙结合。当我第一 一次从 Ant 迁移到 Rake 的
时候，花了很多时间来翻查 Rake 的文档，想看看哪里列出了 Rake 支持的构建任务，就像
Ant 文档中常见的那种列出全部构建任务（和扩展）的长列表。徒劳的搜寻让我开始反感
Rake 文档的不完善，直到我想通了找不到这种文档的原因：我们可以在 Rake 的构建任务
中做任何事情，因为它就是 Ruby 代码。Rake 所做的事情，除了增加一一些方便操作文件列
表的辅助具之外，基本上专注于管理构建任务的依赖关系和日常维护，不去妨碍开发者
的发挥。

很多上下文型的系统在被重新设计成一种 DSL 之后，会发掘出更强的复合能力。Rubyon
Rails 等类似框架所做的事情，其实和以前的 4GL 很相似，只是有一点关键的区别：它们
都被实现成寄居在通用语言里的内部 DSL。当开发者在这些框架里遭遇到 Dietzler 定律的
瓶颈的时候，他们可以绕过框架，直接在底层的通用语言上做文章。Rake 和 Gradle 不约
而同地选择了 DSL 的形式，我也认为，构建脚本在不同项目中的差异性和独特性太高，并
不适合使用上下文型的工具。

我们从本书反复的展示中知道，函数式编程语言的设计哲学不同于命令式语言。命令式语
言希望让状态的修改变得更容易，并且围绕这个目的发展了众多的特性。而函数式语言希
望尽可能减少可变的状态，因此更多地发展了通用性的计算设施。

我认为，我们不应该从静态类型中求索程序抵御错误的能力，从根本上拥抱函数式的概念
才是正确的方向。假如包括数据访问、集成等重要职责在内的所有核心 API，都能以值不
变性为前提来设计的话，那么所有代码都会大幅度地简化。当然，在这种思路下，数据库
和其他基础设施的构建方式也要随之发生变化，但我们知道最后结果一一定会表现出由内而
外的稳定性。
在函数式的内核之上，我们用命令式语言来编写系统中对开发效率要求较高的部分，例如
工作流、业务规则、用户界面，等等。最上层和原来的模型一样，是 DSL 层，其作用也和
原来一样。不过我觉得 DSL 会贯穿系统所有的层次，一直深入到最底层。论据是，有一些
语言大大降低了 DSL 的实现】槛，如 Scala 语言（函数式、静态、强类型）和 Clojure 语
言（函数式、动态、强类型），让我们轻松地借助 DSL 的简洁形式来表达重要的概念。
发生在应用架构模型上的变化是巨大的，而且意味深长。比起动态类型与静态类型的争
拗，当前更有意义的讨论应该是对函数式风格与命令式风格的辨析，而范式转变的影响也
比静态与动态之争更为深远。过去，我们在各种语言下承袭了命令式的设计。向着函数式
风格的转变远不止学习新语法那么简单，但显著的成效是可以预见的。
