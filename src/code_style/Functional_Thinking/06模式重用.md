# 模式重用

如果我们的语言支持的编程范式以对象为本，我们就很容易不自觉地按照对象的术语来思
考所有问题的答案。不过，大多数现代语言都是多范式的，支持对象、元对象、函数式，
以及其他多样化的范式。学会使用不同的范式来处理不同的问题，是开发者进步路上需要
越过的一道坎。

## 函数式语言中的设计模式

传统设计模式在函数式编程的世界中大致有三种归宿。
● 模式已被吸收成为语言的一一部分。
● 模式中描述的解决办法在函数式范式下依然成立，但实现细节有所变化。
● 由于在新的语言或范式下获得了原本没有的能力，产生了新的解决方案（例如很多问题
都可以用元编程干净利落地解决，但 Java 没有元编程能力可用）。

## 函数级别的重用

复合（composition），作为一种重用机制，在函数式语言中主要表现为通过参数来传递作
为第一等语言成分的函数，各种函数式编程库都频繁地运用了这种手法。与面向对象语言
相比，函数式语言的重用发生于较粗的粒度级别上，着眼于提取一。些共通的运作机制，并
参数化地调整其行为。

函数式程序员也喜欢重用代码，只是他们用了另外一套材料来搭建重用体系。函数式
编程不追求复现结构之间经典的（耦合）关系，它以定义各类型“物件”之间“态射”
（morphism）关系的数学分支一范畴论为基础，希望从代码中抽取另一种粗粒度的脉络
而加以重用。大多数应用都离不开对列表元素的操作，函数式的重用机制就建立在列表的
概念，以及可以连同执行上下文一起传递的代码块的概念之上。函数式语言依赖作为第一
等语言成分的函数（第一等的函数允许出现在其他任何语言构造允许出现的位置上）去充
当参数和返回值。

函数式语言不需要那么多辅助性的支撑结构和公式化的死板套语，它可以帮我们卸去一一部
分累赘，同时又实现与传统方式相同的设计概念。例如当语言拥有了闭包特性，就不需要
Command 模式了。从根本上说，设计模式的存在意义就是弥补语言功能上的弱点，例如
不把“行为”用一个本身无甚意义的骨架类包装起来的话，就没办法像传递数值一一样传递
它。当然，Command 模式还有其他用途，例如实现操作回退（undo）， 不过它的主要功能
是打开一条【】路让代码块能够被传递到方法中去执行。

### Template Method 模式

由语言直接提供的高阶函数特性可以让我们节约大量的八股代码，经典的 Command 模式和 Template Method 模式为我们】做了最好的说明。

### Strategy 模式

Strategy 模式也是因为第一等函数而得到简化的一种常用模式。Strategy 模式定义一个算法族，并将每一种算法都在相同的接口下封装起来，令同一族的算法能够互换使用。这样做的好处是算法的变化不影响使用方，也不受使用方的影响。第一等函数让建立和操纵各种策略的工作变得十分简单。

## 结构化重用和函数式重用的对比

第 I 章有这么一段引言：
面向对象编程通过封装不确定因素来使代码能被人理解；函数式编程通过尽量减少不确定因素来使代码能被人理解。
——————Michael Feathers
每天在同一种抽象的包围下工作，我们的头脑会逐渐被它浸染，我们处理问题的方式也会，被潜移默化。这一节我们将尝试通过重构来实现代码重用，并剖析抽象方式对思维角度的影响。

简化状态的封装和使用，是面向对象的目标之一。自然地，状态就成了面向对象的抽象用来解决问题的常规武器，维系状态所需的众多类和交互也因此被派生出来一这些 正是 Michael Feathers 所说的“ 不确定因素”。
函数式编程不喜欢把结构耦合在一一起，它依靠零件之间的复合来组织抽象，以达到减少不确定因素的目的。开发者如果只有面向对象语言的经验，会不容易理解这里面的微妙差别。

### 以结构为载体的代码重用

命令式的、（尤其是）面向对象的编程风格，使用结构和消息作为建筑材料。如果一段面向对象的代码值得重用，那么我们会把它提取到另一个类中，然后通过继承来访问它。

这是一种通过耦合来实现的代码重用：两个代码单元（ClassifierBeta 类和 PrimeBeta 类）因为共享了父类的 number 字段和 getFactors（）方法，而被绑在了一起。语言本身的耦合规则促成了这种用法。面向对象规定了耦合式的交互风格（例如规定我们通过继承来获得对成员变量的访问权），对于各种事物如何耦合我们有一。套预定的规则一这是好事，因
为可以一致地推理各种情况下的行为。继承是很有用的特性，只是面向对象语言滥用了继承，有时候别的一些抽象更符合需要。

因为函数式版本的实现通过参数来传递所有的状态，我们提取出来的重用代码也就不包含任何共享的状态。

耦合与复合的差别是微妙的，但也是重要的。这一节的示例算不上复杂，所以耦合关系不
至于妨碍我们看清代码结构的骨架。可是万一 一需要重构大量代码的时候，我们就会发现处
处都会遇到耦合，因为耦合是面向对象语言非常基本的重用机制。盘根错节、难以理解的
耦合关系已经妨害了面向对象语言下的代码重用，只在一些非常成熟的技术领域，如对象
关系映射、图形界面组件库等少数方面，才取得了令人满意的效果。而在那些面向对象特
征不那么明显的领域（例如各种业务应用），高水平的重用只是美好的愿望。

我们对命令式版本的重构本应该做得更好，假如我们能及时注意到 IDE 提议向父类添加的
protected 成员，制造了父类和子类之间的耦合；假如我们注意到复合是更合适的手段。像
函数式程序员一样思考，意味着要用新的视角去看待编程中的一切方面。代码重用是不同
编程范式的共同追求，但函数式程序员在这个问题上有着不同于命令式抽象的解决途径。
本节开头列举过设计模式在函数式编程下的几种归宿。第一，被语言或运行时吸收掉的模
式，我们举了 Factory、Strategy. Singleton 和 Template Method 模式的例子。第二，模式保
留了原来的语义，但实现发生了彻底的变化，我们对比了 Flyweight 模式基于类的实现和
基于记忆特性的实现。第三，函数式的语言和运行时的语言特性不同以往，它们】解决问题
的方式也不同以往。
