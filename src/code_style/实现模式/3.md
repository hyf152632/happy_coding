# 一种编程理论

就算是再巨细靡遗的模式列表，也不可能涵盖编程中所遇到的每一种情况。你免不了（甚至常常）会遭遇到这种情景：上穷碧落，也找不到对应的现成解决方案。于是便需要有针对特定问题的通用解决方案。这也正是学习编程理论的原因之一。原因之二则是那种知晓如何去做、为何去做之后所带来的胸有成竹。当然，如果把编程的理论和实践结合起来讨论，内容就会更加精彩了。

每个模式都承载着一点点理论。但实际编程中存在一些更加深广的影响力，远不是孤立的模式所能概括的。本章将会讲述这些贯穿于编程中的横切概念，它们分为两类：价值观与原则。价值观是编程过程的统一支配性主题。珍视与其他人沟通的重要性，把代码中多余的复杂性去掉，并保持开放的心态，这才是我工作状态最佳的表现。这些价值观——沟通、简单和灵活——影响了我在编程时所做的每个决策。

价值观有普遍的意义，但往往难以直接应用；模式虽可以直接应用，却是针对于特定情景；原则在价值观和模式之间搭建了桥梁。

价值观、原则和模式，这 3 种元素互为补充，组成了一种稳定的开发方式。模式描述了要做什么，价值观提供了动机，原则把动机转化成了实际行动。

这里的价值观、原则和模式，是通过我的亲身实践、反思以及与其他人的讨论总结出来的。我们都曾经从前人那里吸收经验，最终会形成一种开发方式，但不是唯一的开发方式。不同的价值观和不同的原则会产生不同的方式。把编程方式用价值观、原则和模式的形式展现出来，其优点之一就是可以更加有效地展现编程方法的差异。如果你喜欢用某种方式来做事，而我喜欢另一种，那么就可以识别出我们在哪种层次上存在分歧，从而避免浪费时间。如果我们各自认可不同的原则，那么争论哪里该用大括号根本无助于解决问题。

## 价值观

有 3 个价值观与卓越地编程血脉相连，它们分别是：沟通，简单和灵活。
**最优秀的程序会为未来的扩展留下充分地选择余地，不包含不相关的元素，容易阅读，容易理解。**

### 沟通

**如果阅读者课程理解某段代码，并且进一步修改或使用它，那么这段代码的沟通效果就很好**。

在编程时，我们很容易从计算机的角度进行思考。但只有一面编程一面考虑其他人的感受，我才能编写出好的代码。在这种前提下编写出的代码更加干净易读，更有效率，更清晰地展现出我的想法，给了我全新的视角，减轻了我的压力。我的一些社会性需要得到了自我满足。最开始编程吸引我的部分原因在于我可以通过编程与外界交流，然而，我不想与那些难缠又无法理喻的烦人家伙打交道。过了 20 年，把别人当作空气一样的编程方式才在我眼中褪尽了颜色。耗尽心神去精心搭建一座糖果城堡，于我而言已毫无意义。

Knuth 所提出的文学编程理论促使我把注意力放到沟通上来：程序应该读起来像一本书一样。它需要有情节和韵律，句子间应该有优雅的小小跌宕起伏。

### 简单

**去掉多余的复杂性可以让那些阅读，使用和修改代码的人更容易理解**。**有些复杂性是**内在地，它们准确地反映出所要解决的问题的复杂性。**但有些复杂性地产生完全是**因为我们忙着让程序运行起来，在摆弄过程中留下来的“指甲印”没擦干净\*\*。这种多余的复杂性降低了软件的价值，因为一方面软件正确运行的可能性降低了，另一方面将来也很难进行正确的改动。回顾自己做过的事情，把麦子和糠分开，是编程中不可或缺的一部分。

简单存在于旁观者的眼中。一个可以将专业工具使用得得心应手的高级程序员，他所认为的简单事情对一个初学者来说可能会比登天还难。只有把读者放在心里，你才可以写出动人的散文。同样，只有把读者放在心里，你才可以编写出优美的程序。给阅读者一点挑战没有关系，但过多的复杂性会让你失去他们。

追求简单推动了进化。

在各个层次上都应当要求简单。对代码进行调整，删除所有不提供信息的代码。设计中不出现无关元素。对需求提出质疑，找出最本质的概念。去掉多余的复杂性后，就好像有一束光照亮了余下的代码，你就有机会用全新的视角来处理它们。

沟通和简单通常都是不可分割的。多余的复杂性越少，系统就越容易理解；在沟通方面投入越多，就越容易发现应该被抛弃的复杂性。**不过有时候**我也会发现某种简化会使程序难以理解，这种情况下我**会优先考虑沟通**。这样的情形很少，但常常都表示这里应该有一些我尚未察觉的更大规模的简化。

### 灵活

在三种价值观中，**灵活是衡量那些低效编码与设计实践的一把标尺**。
**
因为**程序的绝大部分开销都是在它第一次部署以后才产生，所以程序必须要容易改动。\*\*想象中明天或许会用得上的灵活性，可能与真正修改代码时所需要的灵活性不是一回事。这就是简单性和大规模测试所带来的灵活性比专门设计出来的灵活性更为有效的原因。

要选择那些提倡灵活性并能够带来及时收益的模式。对于会立刻增加成本但收效却缓慢的模式，最好让自己多一点耐心，先把它们放回口袋里，需要的时候再拿出来。这样就可以用最恰当的方式使用它们。

**灵活性的提高可能以复杂性的提高为代价**。

本书中介绍的模式会通过帮助编程人员创建简单、可以理解、可以修改的应用程序来提高程序的灵活性。

## 原则

实现模式并不是无缘无故产生的。每一种模式都或多或少体现了沟通、
简单和灵活这些价值观。原则是另一个层次上的通用思想，比价值观更贴近
于编程实际，同时又是模式的基础。

我们有很多理由来检查一下这些原则。正如元素周期表帮助人们发现了
新的元素，清晰的原则也可以引出新的模式。原则可以解释模式背后的动机，
它是有普遍意义的。在对立模式间进行选择时，最好的方式就是用原则来说
话，而不是让模式争来争去。最后，如果遇到从未碰到过的情况，对原则的
理解可以充当我们的向导。

例如，假如要使用新的编程语言，我可以根据自己对原则的理解发展出
有效的编程方式，不必盲目模仿现有的编程方式，更不用拘泥于在其他语言
中形成的习惯（虽然可以用任何语言编写 FORTRAN 风格的代码，但不该那
么做）。

对原则的充分理解使我能够快速地学习，即使在新鲜局面下仍然能够一以贯之地符合原则。接下来的部分，我将为你讲述隐藏在模式背后的原则。

### 1.局部化影响

组织代码结构时，要保证变化只会产生局部化影响。如果这里的一个变化会引出那里的一个问题，那么变化的代价就会急剧上升了。把影响范围缩到最小，代码就会有极佳的沟通效果。
实现模式背后一条最主要的动机就是减少变化所引起的代价，所以局部化影响这条原则也是很多模式的形成缘由之一。

### 2.最小化重复

最小化重复这条原则有助于保证局部化影响。如果相同的代码出现在很
多地方，那么改动其中一处副本时，就不得不考虑是否需要修改其他副本；变动不再只发生在局部。代码的复制越多，变化的代价就越大。

复制代码只是重复的一种形式。并行的类层次结构也是其一，同样破坏
了局部化影响原则。如果修改一处概念需要修改两个或更多的类层次结构，
就表示变化的影响已经扩散了。此时应重新组织代码，让变化只对局部产生
影响。这种做法可以有效改进代码质量。

重复不容易被预见到，有时在出现以后一段时间才会被觉察。重复不是
罪过，它只是增加了变化的开销。

**我们可以把程序拆分成许多更小的部分—小段语句、小段方法、小型对象和小型包，从而消除重复**。
大段逻辑很容易与其他大段逻辑出现重复的代码片断，于是就有了模式诞生的可能，虽然不同的代码段落中存在差异，
但也有很多相似之处。如果能够清晰地表述出哪些部分程序是等同的，哪些部分相似性很少，而哪些部分则截然不同，程序就会更容易阅读，修改的代价也会更小。

### 3.将逻辑与数据捆绑

局部化影响的必然结果就是将逻辑与数据捆绑。把逻辑与逻辑所处理的
数据放在一起，如果有可能尽量放到一个方法中，或者退一步，放到一个对
象里面，最起码也要放到一个包下面。在发生变化时，逻辑和数据很可能会
同时被改动。如果它们被放在一起，那么修改它们所造成的影响就会只停留
在局部。

### 4.对称性

对称性也是我随时随地运用的一项原则。程序中处处充满了对称性。比
如 add()方法总会伴随着 remove()方法，一组方法会接受同样的参数，一个
对象中所有的字段都具有相同的生命周期。识别出对称性，把它清晰地表述
出来，代码将更容易阅读。一旦阅读者理解了对称性所涵盖的某一半，他们
就会很快地理解另外一半。

程序中的对称性指的是概念上的对称，而不是图形上的对称。代码中对称性的表现，
是无论在什么地方，同样的概念都以同样的形式呈现。

在准备消灭重复之前，常常需要寻找并表示出代码中的对称性。如果在很多代码中都存在类似的想法，那么可以先把它们用对称的方式表示出来，让接下来的重构有一个良好的开端。

### 5. 声明式表达

实现模式背后的另一条原则是尽可能声明式地表达出意图。

### 6.变化率

把具有相同变化率地逻辑，数据放在一起，把具有不同变化率地逻辑，数据分离。
