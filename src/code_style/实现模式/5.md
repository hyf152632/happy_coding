# 类

类的概念早在柏拉图之前就出现了。

面向对象编程把程序划分成许多类，类是对一组相似地东西的一般归纳，而对象而是这些东西本身。

类(class)————用一个类来表示“这些数据应该放在一起，还有这些逻辑应该也和它们在一起“

数据的变化比逻辑要频繁得多，正是这种现象让类有了存在的意义。
每个类其实就是这样的声明：这些逻辑应该放在一起，它们的变化不像它们所操作的数据那么频繁；这些数据也应该放在一起，它们的变化的频率差不多，而且由与之关联得逻辑来负责处理。
学会如何用类来包装逻辑和如何表达逻辑得变化，这是有效使用对象编程得重要部分。

在由对象搭建而成得程序中，类是相对昂贵得设计元素。一个类应该做一些有直接而明显的意义得事情。减少类的数量是对系统的改进，只要剩下的类不因此而变得臃肿就好。

找到一个贴切得名字是编程中最令人开心的时刻之一。贴切得名字能引发连锁反应，带来更深入的简化与改进。

权衡长度与表现力。

与他人沟通是类名得用途，如果仅仅为了和计算机沟通，只要给每个类编号就足够了。太长得类名读写都费劲，太短得类名又会考验阅读者得记忆力。如果一组类的名字体现不出它们之间的相关性，阅读者就很难对它们形成整体印象，也很难回忆起它们的关系。应该用类名来讲述代码的故事。

针对接口编程，不要针对实现编程。
不要针对实现编程。从另一个角度来说，这也意味着设计决策不应该暴露给不必要的地方。
如果大部分代码只知道我在处理一个容器，那么我就可以随时改变这个容器的具体实现。
但有时不得不指定具体类，否则计算就没法进行下去。

每层接口都有成本：需要学习它，理解它，给它写文档，调试它，组织它，浏览它，还有给它命名。
并不是接口数量越多软件成本就会越少，只有需要接口带来的灵活性时才值得为它付出成本。

通过预先思考来弄清软件将来的样子，其效果是相当有限的。

所有这些因素————对灵活性得需要，灵活性的成本，”何处需要灵活性“的不可预测————加在一起让我相信：应该在确定无疑地需要灵活性时，才应该引入这种灵活性。引入灵活性是有代价的，因为需要修改已有的软件。如果不能独自完成所有需要的修改，成本就会更高。

Java 有两种方式来表现抽象接口：超类和 interface.它们在应对变化时涉及的成本各有不同。

要用 Java 表达“这是我要完成的任务，除此之外得细节不归我操心”，可以声明一个 interface。

把具有可变状态的对象作为思考计算问题的一种方式确实很有价值，但它并非唯一的方式。
当问题可以被归约到由绝对真实和确定构成的，在其中可以谈论“永恒真理”的抽象世界时，另一种思考这类问题的方式已经发展了数千年，那就是数学。

目前的编程语言则是这两种风格的混合体。

这种函数式的计算风格永远不会改变任何状态，只是创建新的值。如果你面对一个可能只是暂时静止的情景，随后的操作或者查询都针对这个情景来进行。那么函数式的风格比较合适。如果面对的情景总在不断变化，那么有状态的风格比较合适。问题是，有些情景用两种方式来看待都可以，那么又该如何选择呢？

有时候，组合使用状态可变的对象和像数值一样不可变的对象，能够最好地表现你的程序。

特化
清晰地描述计算过程中相似性与差异性的相互作用，可以让程序更容易阅读，使用和修改。
最简单的变化是状态的差异。字符串“abc”显然是与"def"不同的，但操作这两个字符串的算法是一样的。例如所有字符串的长度都以同样的方式来计算。

最复杂的变化是在逻辑上完全不同。符号积分子程序和数学式排版子程序在逻辑上毫无共通之处，虽然它们接受的输入可能是一样的。

大多数程序位于两个极端————“相同的逻辑处理不同的数据”和”不同的逻辑处理相同的数据“————之间的某个位置：数据可能大多相同，但略有区别；逻辑可能大多相同，但略有区别。

子类
对象技术刚开始流行时，继承一度被视为万灵药。一开始人们用继承来分类：Train 是 Vehicle 的子类，不管两者是否共享任何实现。不久，一些人又发现：既然继承所做的就是共享实现，用它来抽取共同的实现部分就是最有效的办法了。但好景不长，继承的局限性很快就暴露了出来。
首先，这张牌只能用一次；如果事后发现一些变化情况无法用子类的方式很好地表达，就得先花点功夫把代码从继承关系中解开，然后才能重新组织它。
其次，使用者必须首先理解超类，然后才可能理解子类，随着超类变得复杂，这个问题会更加严重。
第三，对超类的修改颇有风险，因为子类有可能依赖于超类实现中的某个微妙的属性。
最后，在过深的继承体系中，所有这些问题都会出现。

合适的子类能帮助人们用一两个方法准确地描述出自己想要的计算逻辑。要得到合适的子类，关键在于把超类中的逻辑进行彻底地划分，直到每个方法只做一件事。
在编写子类时，应该可以在覆盖一个方法而不管其他方法。

子类继承还有一个局限：它不能表现不断变化的逻辑。你所要表现的变化情况在创建对象时就已经清楚了，此后无法再改变。如果需要逻辑随时变化，条件语句或是委派就能排上用场。

在由对象组成的程序中，多态消息是表达选择的基本方法之一。为了让消息能起到选择的作用，能够接收到该消息的对象就必须不止一种。

多态消息的优美之处在于，它们给系统开启了变化的机会。如果程序中的某一部分要把一些字节写到另一个系统，引入抽象的 Socket 就能让开发者随时改变套接字的具体实现而不影响其使用者。
清晰的表达与灵活性，两者的天作之合正是面向对象语言成为主流的原因所在。

条件语句
条件语句的好处是，所有逻辑仍然在同一个类里，阅读者不必四处寻找所有可能的计算路径。但条件语句的缺点是：除了修改对象本身的代码之外，没有其他办法修改它的逻辑。

条件语句的增加会降低可靠性。

这些问题都可以解决，办法是把条件逻辑变成消息，发送给子类或者委派（哪种方式更好取决于代码的具体情况）。如果条件逻辑出现重复，或者各个条件分支上的逻辑差异很大，那么用消息的方式来描述会比显示的条件逻辑更好。此外，频繁变化的条件逻辑也最好是用消息来表现。这样可以使各个分支的修改更简单，对其他分支的影响更小。

简而言之，条件语句的好处在于简单和局部化。如果用得太多，这些好处反而变成弱点了。
