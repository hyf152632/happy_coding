# 第一部分 函数式思想

## 1

当考虑应用设计时，你应该问问自己是否遵从了以下的设计原则：

- 可扩展性————我是否需要不断地重构代码来支持额外的功能
- 易模块化————如果我更改了一个文件，另一个文件会不会受影响
- 可重用性————是否有很多重复的代码？
- 可测性————给这些函数添加单元测试是否困难
- 易推理性————我写的代码是否非结构化严重并难以推理

函数式编程基于一些简单的概念，但它还是需要你换一种思考问题的方式。
函数式编程不是一种新工具或新的 API，而是另一种解决问题的方式，一旦你了解了它的基本原则，所要解决的问题将变得很直观。

函数式编程的目标是使用函数来抽象作用在数据之上的控制流与操作，从而在系统中消除副作用并减少对状态的改变。

函数式编程是声明式编程

命令式编程将计算机程序视为一系列自上而下的断言，通过修改系统的各个状态来计算最终的结果。

命令式编程很具体地告诉计算机如何执行某个任务。
而声明式编程是将程序的描述与求值分离开来。它关注于如何用各种表达式来描述程序逻辑，而不一定要指明其控制流或状态的变化。
你可以在 SQL 语句中找到声明性编程的例子。
如果使用函数式来解决相同的问题，只需要对应用在每个函数元素上的行为给予关注，将循环交给系统的其他部分去控制。

函数式编程旨在尽可能地提高代码的无状态性和不变性。无状态的代码不会改变或者破坏全局的状态。但要做到这一点，就要使用那些没有副作用和状态变化的函数————纯函数

函数式编程基于一个前提，即使用纯函数构建具有不可变性的程序。纯函数具有以下性质：

- 输出仅取决于提供的输入，而不依赖于任何在函数求值期间或调用间隔时可能变化的隐藏状态和外部状态
- 不会造成超出其作用域的变化，例如修改全局对象或引用传递的参数

如果一个函数对于相同的输入始终产生相同的结果，那么就说它是引用透明的。

Program = [Input] + [func1, func2, func3, ...] -> Output

引用透明和可置换性

存储不可变数据

函数式编程是指为创建不可变的程序，通过消除外部可见的副作用，来对纯函数的声明式的求值过程。

函数式编程的优点：
促使将任务分解成简单的函数；  
使用流式的调用链来处理数据；  
通过响应式范式降低事件驱动代码的复杂性；

从宏观上讲，函数式编程实际上是**分解**（将程序拆分为小片段）和**组合**（将小片段连接到一起）之间的相互作用。

函数式编程的模块化的概念与单一职责原则息息相关，也就是说，函数都应该拥有单一的目的。

函数式的组合提高了抽象的层次，可以清晰地勾勒出代码的所有步骤，但又不暴露任何底层细节的步骤。

使用流式链来处理数据

## 2 高阶 js

在数据（对象属性）与行为（函数）的组织上，面向对象和函数式的主要差别。

面向对象的应用程序大多是命令式的，因此在很大程度上依赖于使用基于对象的封
装来保护其自身和继承的可变状态的完整性，再通过实例方法来暴露或修改这些状态。
其结果是，对象的数据与其具体的行为以一种内聚的包裹的形式紧耦合在一起。而这就
是面向对象程序的目的，也正解释了为什么对象是抽象的核心。
再看函数式编程，它不需要对调用者隐藏数据，通常使用一些更小且非常简单的数
据类型。由于一切都是不可变的，对象都是可以直接拿来使用的，而且是通过定义在对
象作用域外的函数来实现的。换句话说，数据与行为是松耦合的。

面向对象的设计着重于数据及数据之间的关系，函数式编程则关注于操作如何执行，即行为。

尽管它们之间存在差异，但有效构建应用程序的方法是混合两种范式。一方面，可
以使用与组成类型之间存在自然关系的富领域模型；另一方面，可以拥有一组能够应用
于这些类型之上的纯函数。其中界限的确定取决于代码编写者是否对任一编程范式应用
自如。由于 JavaScript 既是面向对象的，又是函数式的，因此在编写函数式代码时，需
要特别注意控制状态的变化。

管理 JavaScript 对象的状态

程序的状态可以定义为在任一时刻存储在所有对象之中的数据快照。可惜的是，
JavaScript 是在对象状态安全方面做得最差的语言之一。JavaScript 的对象是高度动态
的，其属性可以在任何时间被修改、增加或删除。

自由的代价是重大的责任。尽管这会让你自由地去做一些如动态创建属性这样的灵
活的事情，但在中大型项目中，这也会使得代码极难维护。

虽然使用闭包可以起到一定的私有作用，但是尽管该对象的内部状态得到了保护，但其行为仍然可变，因为可以动态地删除或替换它的任何方法。

利用 Ojbect.freeze() 冻结对象

使用 Lenses 定位并修改对象图

Lenses 也被称为函数式引用，是函数式程序设计中用于访问和不可改变地操纵状态数据类型属性的解决方案。从本质上讲，Lenses 与写时复制策略的工作方式类似，即采用一个能够合理管理和赋值状态的内部存储部件。
然而，开发者不需要自行实现，而是可以使用一个称为 Ramda.js 的函数式 JavaScript 库（附录中包含使用该库以及其他库的详细信息）。默认情况下，Ramda 使用全局对象 R 来公开所有的功能。可以使用 R.lensProp 来创建一个包装了 Person 的 lastname 属性的 Lens。

```js
R.lensProp
var person = new Person('Alonzo', 'Church', '444-44-4444')
var lastnameLens = R.lenseProp('lastName')
// 可以使用R.view来读取该属性的内容：
R.view(lastnameLens, person) //-> 'Church'
```

从实践角度看，它类似于一个 get_lastname() 方法。目前还没有什么令人印 象深刻的东西。那么，如何实现 setter 呢？这里就是其神奇魔力的所在。调用 R.set 时，它创建并返回一个全新的对象副本，其中包含一个新的属性值，并保留原始实例状 态（免费的写时复制！）：

```js
var newPerson = R.set(lastnameLens, 'Mourning', person)
newPerson.lastname //-> 'Mourning'
person.lastname //-> 'Church'
```

JavaScript 函数有两个支柱性的重要特性：一等的和高阶的。

在 JavaScript 中，任何函数都是 Function 类型的一个实例。函数的 length 属 性可以用来获取形参的数量，而像 apply()和 call()方法可以用来调用函数并加入上下文

高阶函数

因为函数的一等性和高阶性，JavaScript 函数具有值的行为，也就是说，函数就是 一个基于输入的且尚未求值的不可变的值。这一原则将贯穿整个函数式编程的学习，尤 其体现在第 3 章将要介绍的函数链的内容中。函数链的建立基于一些指向不同代码片段 的函数名，它们将作为整个表达式的各部分被执行。

```js
function printPeopleInTheUs(people) {
  for (let i = 0; i < people.length; i++) {
    var thisPerson = people[i]
    if (thisPerson.address.country === 'US') {
      console.log(thisPerson)
    }
  }
}
printPeopleInTheUs([p1, p2, p3])

function printPeople(people, selector, printer) {
  people.forEach(function(person) {
    if (selector(person)) {
      printer(person)
    }
  })
}
var inUs = person => person.address.country === 'US'
printPeople(people, inUs, console.log)

//可以使用 Lens 来创建可以访问对象属性的函数：
var countryPath = ['address', 'country']
var countryL = R.lens(R.path(countryPath), R.assocPath(countryPath))
var inCountry = R.curry((country, person) => R.equals(R.view(countryL, person), country))
people.filter(inCountry('US')).map(console.log)
```

函数的调用类型

闭包和作用域

在 JavaScript 出现之前，闭包只存在于函数式编程语言中，用于编写某些特殊的应 用程序。JavaScript 是第一个在主流开发中应用闭包的语言，显著地改变了开发者编写 代码的方式。

闭包是一种能够在函数声明过程中将环境信息与所属函数绑定在一起的数据结构。 它是基于函数声明的文本位置的，因此也被称为围绕函数定义的静态作用域或词法作用 域。闭包能够使函数访问其环境状态，使得代码更清晰可读。你很快就会看到，闭包不 仅应用于函数式编程的高阶函数中，也可用于事件处理和回调、模拟私有成员变量，还 能用于弥补一些 JavaScript 的不足

闭包的实际应用：

- 模拟私有变量

  - 还可以用来管理全局命名空间。使用闭包来隐藏整个模块的私有方法和数据————模块模式

    ```js
    var MyModule = (function MyModule(export){
        let _myPrivateVar = ''
        export.method1 = function() {

        }
        export.method2 = function() {

        }
    })(MyModule | {})
    ```

- 异步服务端调用（回调函数）
- 模拟块作用域变量
