#

## hello,world

- 当看到符号 ! 的时候，就意味着调用的是宏而不是普通函数。

- 编译和运行是彼此独立的步骤：
  `rustc main.rs`

- 如果你更熟悉动态语言，如 Ruby、Python 或 JavaScript，则可能不习惯将编译和运行分为两个单独的步骤。Rust 是一种 预编译静态类型（ahead-of-time compiled）语言，这意味着你可以编译程序，并将可执行文件送给其他人，他们甚至不需要安装 Rust 就可以运行。如果你给他人一个 .rb、.py 或 .js 文件，他们需要先分别安装 Ruby，Python，JavaScript 实现（运行时环境，VM）。不过在这些语言中，只需要一句命令就可以编译和运行程序。这一切都是语言设计上的权衡取舍。

- Cargo 是 Rust 的构建系统和包管理器
  使用 Cargo 创建项目：
  `cargo new hello_cargo`
  `cd hello_cargo`
  构建并运行 Cargo 项目：
  `cargo build`
  `./target/debug/hello_cargo`
  同时编译并运行：
  `cargo run`
  快速检查代码确保其可以编译，但并不产生可执行文件：
  `cargo check`
  通常 cargo check 要比 cargo build 快得多，因为它省略了生成可执行文件的步骤。如果你在编写代码时持续的进行检查，cargo check 会加速开发！为此很多 Rustaceans 编写代码时定期运行 cargo check 确保它们可以编译。当准备好使用可执行文件时才运行 cargo build。
  可以使用 cargo build 或 cargo check 构建项目。
  可以使用 cargo run 一步构建并运行项目。
  有别于将构建结果放在与源码相同的目录，Cargo 会将其放到 target/debug 目录。
  发布(release)构建：
  `cargo build --release`
  这会在 target/release 而不是 target/debug 下生成可执行文件。这些优化可以让 Rust 代码运行的更快，不过启用这些优化也需要消耗更长的编译时间。这也就是为什么会有两种不同的配置：一种是为了开发，你需要经常快速重新构建；另一种是为用户构建最终程序，它们不会经常重新构建，并且希望程序运行得越快越好。如果你在测试代码的运行时间，请确保运行
  修改 Cargo.toml, 引入依赖, 然后不修改任何代码，运行`cargo build` cargo 就会自己下载依赖
  更新 crate 到一个新版本：
  `cargo update`
  当更新了 `Cargo.toml`中的依赖时，然后运行 `cargo build` 时， Cargo 会从 registry 更新可用的 crate，并根据你指定的新版本重新计算。

## 通用编程概念

- 关键字
- 标识符
  第一个字符是字母。
  其它字符是字母数字或者 \_。
  或者是：

  第一个字符是 _。
  标识符需多于一个字符。单独的 _ 不是标识符。
  其它字符是字母数字或者 \_。

- 变量与可变性：
  变量默认是不可变的。不过，你仍然可以使用可变变量。
  不过可变性也是非常有用的。变量只是默认不可变；正如在第二章所做的那样，你可以在变量名之前加 mut 来使其可变。除了允许改变值之外，mut 向读者表明了其他代码将会改变这个变量值的意图。
  声明常量使用 const 关键字而不是 let，并且 必须 注明值的类型。
  `const MAX_POINTS: u32 = 100_000;`
  隐藏(Shadowing)
  我们可以定义一个与之前变量同名的新变量，而新变量会 隐藏 之前的变量。Rustacean 们称之为第一个变量被第二个 隐藏 了，这意味着使用这个变量时会看到第二个值。可以用相同变量名称来隐藏一个变量，以及重复使用 let 关键字来多次隐藏
  隐藏与将变量标记为 mut 是有区别的。当不小心尝试对变量重新赋值时，如果没有使用 let 关键字，就会导致编译时错误。通过使用 let，我们可以用这个值进行一些计算，不过计算完之后变量仍然是不变的。
  mut 与隐藏的另一个区别是，当再次使用 let 时，实际上创建了一个新变量，我们可以改变值的类型，但复用这个名字。
- 数据类型
  在 Rust 中，每一个值都属于某一个 数据类型（data type），这告诉 Rust 它被指定为何种数据，以便明确数据处理方式。我们将看到两类数据类型子集：标量（scalar）和复合（compound）。
  记住，Rust 是 静态类型（statically typed）语言，也就是说在编译时就必须知道所有变量的类型。根据值及其使用方式，编译器通常可以推断出我们想要用的类型。当多种类型均有可能时，比如第二章的 “比较猜测的数字和秘密数字” 使用 parse 将 String 转换为数字时，必须增加类型注解：`let guess: u32 = "42".parse().expect("Not a number");`

  - 标量类型：
    标量（scalar）类型代表一个单独的值。Rust 有四种基本的标量类型：**整型**、**浮点型**、**布尔类型**和**字符类型**。你可能在其他语言中见过它们。让我们深入了解它们在 Rust 中是如何工作的。
    - 整型：整数 是一个没有小数部分的数字。
    - 浮点型：Rust 也有两个原生的 浮点数（floating-point numbers）类型，它们是带小数点的数字。Rust 的浮点数类型是 f32 和 f64，分别占 32 位和 64 位。默认类型是 f64，因为在现代 CPU 中，它与 f32 速度几乎一样，不过精度更高。
    - 布尔型： `let f: bool = false;`
    - 字符类型： Rust 的 char 类型是语言中最原生的字母类型，如下代码展示了如何使用它。（注意 char 由单引号指定，不同于字符串使用双引号。）
  - 复合类型：复合类型（Compound types）可以将多个值组合成一个类型。Rust 有两个原生的复合类型：元组（tuple）和数组（array）。

    - 元祖类型
      元组是一个将多个其他类型的值组合进一个复合类型的主要方式。

      我们使用包含在圆括号中的逗号分隔的值列表来创建一个元组。元组中的每一个位置都有一个类型，而且这些不同值的类型也不必是相同的。这个例子中使用了可选的类型注解：
      `let tup: (i32, f64, u8) = (500, 6.4, 1);`
      tup 变量绑定到整个元组上，因为元组是一个单独的复合元素。为了从元组中获取单个值，可以使用模式匹配（pattern matching）来解构（destructure）元组值: `let(x, y, z) = tup`
      除了使用模式匹配解构外，也可以使用点号(.)后跟值得索引来直接访问它们。

    - 数组类型：
      另一个包含多个值的方式是 数组（array）。与元组不同，数组中的每个元素的类型必须相同。Rust 中的数组与一些其他语言中的数组不同，因为 Rust 中的数组是固定长度的：一旦声明，它们的长度不能增长或缩小。
      当你想要在栈（stack）而不是在堆（heap）上为数据分配空间（第四章将讨论栈与堆的更多内容），或者是想要确保总是有固定数量的元素时，数组非常有用。但是数组并不如 vector 类型灵活。vector 类型是标准库提供的一个 允许 增长和缩小长度的类似数组的集合类型。当不确定是应该使用数组还是 vector 的时候，你可能应该使用 vector。
      数组的类型比较有趣；它看起来像 [type; number]。例如：
      `let a: [i32; 5] = [1, 2, 3, 4, 5];`
      首先是方括号；这看起来像创建数组的语法。其中有两部分由分号分割的信息。第一部分是数组中每个元素的类型。因为所有元素都是相同类型的，所以只需列出一次。分号之后，是一个表示数组长度的数字。因为数组是固定长度的，该数字也一直保持不变，即便数组的元素被修改，它也不会增长或缩小
      数组是一整块分配在栈上的内存。可以使用索引来访问数组的元素: `let first = a[0]`

- 函数
  main 函数，是很多程序的入口点
  fn 关键字用来声明新函数
  Rust 代码中的函数和变量名使用 snake case 规范风格。在 snake case 中，所有字母都是小写并使用下划线分隔单词
  Rust 不关心函数定义于何处，只要定义了就行。
  函数也可以被定义为拥有 参数(parameters), 参数是特殊变量，是函数签名的一部分。
  在函数签名中，必须声明每个参数的类型。这是 Rust 设计中一个经过慎重考虑的决定：要求在函数定义中提供类型注解，意味着编译器不需要你在代码的其他地方注明类型来指出你的意图。
  包含语句和表达式的函数体
  Rust 是一门基于表达式(expression-based)的语言。
  语句(Statements)是执行一些操作但不返回值得指令。
  表达式(Expression)计算并产生一个值。
  使用 let 关键字创建变量并绑定一个值是一个语句。`let y = 6;` 是一个语句。
  语句不返回值。
  `let y = 6` 语句并不返回值，所以没有可以绑定到 x 上的值。这**与其他语言不同**，例如 C 和 Ruby，它们的赋值语句会返回所赋的值。在这些语言中，可以这么写 `x = y = 6`，这样 x 和 y 的值都是 6；Rust 中不能这样写。
  表达式会计算出一些值，并且你将编写的大部分 Rust 代码是由表达式组成的。考虑一个简单的数学运算，比如 `5 + 6`，这是一个表达式并计算出值 11。
  **表达式可以是语句的一部分**：语句 `let y = 6;` 中的 `6` 是一个表达式，它计算出的值是 6。
  **函数调用是一个表达式**。
  **宏调用是一个表达式**。
  我们用来创建新作用域的**大括号（代码块），{}**，也是一个表达式。

  ```rust
  let y = {
   let x = 3;
   x + 1
   };
   //其中花括号部分是一个表达式，这个代码块的值是4.这个值作为 let 语句的一部分被绑定到 y 上。注意结尾没有分号的那一行 x+1，与你见过的大部分代码行不同。表达式的结尾没有分号。如果在表达式的结尾加上分号，它就变成了语句，而语句不会返回值。在接下来探索具有返回值的函数和表达式时要谨记这一点。
  ```

  表达式的结尾没有分号。如果在表达式的结尾加上分号，它就变成了语句，而语句不会返回值。
  具有返回值的函数。
  函数可以向调用它的代码返回值。我们并不对返回值命令，但要在箭头(->)后声明它的类型。
  在 Rust 中，函数的返回值等同于函数体最后一个表达式的值。
  使用 `return`关键字和指定值，可从函数中提前返回；但大部分函数隐式的返回最后的表达式。

- 注释
  一个简单的注释： `// hello, world`

- 控制流
  - if 表达式
    也可以包含一个可选的 else 表达式来提供一个在条件为假时应当执行的代码块，这里我们就这么做了。
    如果不提供 else 表达式并且条件为假时，程序会直接忽略 if 代码块并继续执行下面的代码。
    另外值得注意的是代码中的 **条件 必须 是 bool 值**。如果条件不是 bool 值，我们将得到一个错误。
    使用 `else if`处理多重条件
    在 let 语句中使用 if
    因为 if 是一个表达式，我们可以在 let 语句的右侧使用它
  - 循环
    Rust 有三种循环：loop、while 和 for
    - 使用 `loop` 重复执行代码
      `loop` 关键字告诉 Rust 一遍又一遍地执行一段代码直到你明确要求停止。
      可以使用 `break` 关键字来告诉程序何时停止循环。
      从循环中返回：可以将该值放在 break 表达式后，以便在循环外使用
    - `while` 条件循环
      这种结构消除了很多使用 loop、if、else 和 break 时所必须的嵌套，这样更加清晰。当条件为真就执行，否则退出循环
    - 使用 `for` 遍历集合
      `for element in a.iter()`
      for 循环的安全性和简洁性使得它成为 Rust 中使用最多的循环结构。即使是在想要循环执行代码特定次数时

## 所有权

所有权（系统）是 Rust 最独特的功能，其令 Rust 无需垃圾回收（garbage collector）即可保障内存安全。
我们将讲到所有权以及相关功能：借用、slice 以及 Rust 如何在内存中布局数据。

Rust 的核心功能（之一）是 所有权（ownership）。虽然该功能很容易解释，但它对语言的其他部分有着深刻的影响。

所有运行的程序都必须管理其使用计算机内存的方式。一些语言中具有垃圾回收机制，在程序运行时不断地寻找不再使用的内存；在另一些语言中，程序员必须亲自分配和释放内存。Rust 则选择了第三种方式：通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查。在运行时，所有权系统的任何功能都不会减慢程序。

当你理解了所有权，你将有一个坚实的基础来理解那些使 Rust 独特的功能。在本章中，你将通过完成一些示例来学习所有权，这些示例基于一个常用的数据结构：字符串。

跟踪哪部分代码正在使用堆上的哪些数据，最大限度的减少堆上的重复数据的数量，以及清理堆上不再使用的数据确保不会耗尽空间，这些问题正是所有权系统要处理的。一旦理解了所有权，你就不需要经常考虑栈和堆了，不过明白了**所有权的存在就是为了管理堆数据**，能够帮助解释为什么所有权要以这种方式工作。

所有权规则：

- Rust 中的每个值都有一个被称为其 所有者(owner)的变量
- 值有且只有一个所有者
- 当所有者（变量）离开作用域，这个值将被丢弃

```rust
{                      // s 在这里无效, 它尚未声明
    let s = "hello";   // 从此处起，s 是有效的

    // 使用 s
}                      // 此作用域已结束，s 不再有效
```

String 类型
这里使用 String 作为例子，并专注于 String 与所有权相关的部分。这些方面也同样适用于标准库提供的或你自己创建的其他复杂数据类型。

我们已经见过字符串字面值，字符串值被硬编码进程序里。字符串字面值是很方便的，不过他们并不适合使用文本的每一种场景。原因之一就是他们是不可变的。另一个原因是并不是所有字符串的值都能在编写代码时就知道：例如，要是想获取用户输入并存储该怎么办呢？为此，Rust 有第二个字符串类型，String。
`let s = String::from("hello");`
这两个冒号(::)是运算符，允许将特定的 `from` 函数置于 String 类型的命名空间(namespace)下，而不需要使用类似 string_from 这样的名字。
可以修改此类 字符串:

```rust
let mut s = String::from("hello");

s.push_str(", world!");
println!("{}", s);
```

为什么 String 可变而字面值却不行呢？区别在于两个类型对内存的处理上。

对于 String 类型，为了支持一个可变，可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容。
这意味着：

- 必须在运行时向操作系统请求内存
- 需要一个当我们处理完 String 时将内存返回给操作系统的方法

第一部分由我们完成：当调用 String::from 时，它的实现 (implementation) 请求其所需的内存。这在编程语言中是非常通用的。

然而，第二部分实现起来就各有区别了。在有 垃圾回收（garbage collector，GC）的语言中， GC 记录并清除不再使用的内存，而我们并不需要关心它。没有 GC 的话，识别出不再使用的内存并调用代码显式释放就是我们的责任了，跟请求内存的时候一样。从历史的角度上说正确处理内存回收曾经是一个困难的编程问题。如果忘记回收了会浪费内存。如果过早回收了，将会出现无效变量。如果重复回收，这也是个 bug。我们需要精确的为一个 allocate 配对一个 free。

Rust 采取了一个不同的策略：内存在拥有它的变量离开作用域后就被自动释放。

```rust
{
  let s = String::from("hello");  // 从此处起， s 是有效的

  // 使用 s
}     // 此作用域已结束
// s 不再有效
```

之前我们提到过当变量离开作用域后，Rust 自动调用 drop 函数并清理变量的堆内存。

为了确保内存安全，这种场景下 Rust 的处理有另一个细节值得注意。与其尝试拷贝被分配的内存，Rust 则认为 s1 不再有效，因此 Rust 不需要在 s1 离开作用域后清理任何东西。看看在 s2 被创建之后尝试使用 s1 会发生什么；这段代码不能运行：

```rust
let s1 = String::from("hello");
let s2 = s1
println!("{}, world", s1);
```

- 变量与数据交互的方式（一）：移动

Rust 禁止使用无效的引用

如果你在其他语言中听说过术语 浅拷贝（shallow copy）和 深拷贝（deep copy），那么拷贝指针、长度和容量而不拷贝数据可能听起来像浅拷贝。不过因为 Rust 同时使第一个变量无效了，这个操作被称为 移动（move），而不是浅拷贝。上面的例子可以解读为 s1 被 移动 到了 s2 中。

另外，这里还隐含了一个设计选择：Rust 永远也不会自动创建数据的 “深拷贝”。因此，任何 自动 的复制可以被认为对运行时性能影响较小。

- 变量与数据交互的方式（二）：克隆

如果我们 确实 需要深度复制 String 中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做 clone 的通用函数。

```rust
let s1 = String::from("hello");
let s2 = s1.clone();
```

当出现 clone 调用时，你知道一些特定的代码被执行而且这些代码可能相当消耗资源。你很容易察觉到一些不寻常的事情正在发生。

只在栈上的数据：拷贝

```rust
let x = 5;
let y = x;

println!("x = {}, y = {}", x, y);
```

但这段代码似乎与我们刚刚学到的内容相矛盾：没有调用 clone，不过 x 依然有效且没有被移动到 y 中。

原因是像整型这样的在编译时已知大小的类型被整个存储在栈上，所以拷贝其实际的值是快速的。这意味着没有理由在创建变量 y 后使 x 无效。换句话说，这里没有深浅拷贝的区别，所以这里调用 clone 并不会与通常的浅拷贝有什么不同，我们可以不用管它。

- 所有权与函数

将值传递给函数在语义上与给变量赋值相似。向函数传递值可能会移动或者复制，就像赋值语句一样。

```rust
fn main() {
    let s = String::from("hello");  // s 进入作用域

    takes_ownership(s);             // s 的值移动到函数里 ...
                                    // ... 所以到这里不再有效

    let x = 5;                      // x 进入作用域

    makes_copy(x);                  // x 应该移动函数里，
                                    // 但 i32 是 Copy 的，所以在后面可继续使用 x

} // 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，
  // 所以不会有特殊操作

fn takes_ownership(some_string: String) { // some_string 进入作用域
    println!("{}", some_string);
} // 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放

fn makes_copy(some_integer: i32) { // some_integer 进入作用域
    println!("{}", some_integer);
} // 这里，some_integer 移出作用域。不会有特殊操作
```

- 返回值与作用域

返回值也可以转移所有权

```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership 将返回值
                                        // 移给 s1

    let s2 = String::from("hello");     // s2 进入作用域

    let s3 = takes_and_gives_back(s2);  // s2 被移动到
                                        // takes_and_gives_back 中,
                                        // 它也将返回值移给 s3
} // 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，
  // 所以什么也不会发生。s1 移出作用域并被丢弃

fn gives_ownership() -> String {             // gives_ownership 将返回值移动给
                                             // 调用它的函数

    let some_string = String::from("hello"); // some_string 进入作用域.

    some_string                              // 返回 some_string 并移出给调用的函数
}

// takes_and_gives_back 将传入字符串并返回该值
fn takes_and_gives_back(a_string: String) -> String { // a_string 进入作用域

    a_string  // 返回 a_string 并移出给调用的函数
}
```

**变量的所有权总是遵循相同的模式：将值赋给另一个变量时移动它。当持有堆中数据值的变量离开作用域时，其值将通过 drop 被清理掉，除非数据被移动为另一个变量所有**。

在每一个函数中都获取所有权并接着返回所有权有些啰嗦。如果我们想要函数使用一个值但不获取所有权该怎么办呢？如果我们还要接着使用它的话，每次都传进去再返回来就有点烦人了，除此之外，我们也可能想返回函数体中产生的一些数据。

- 引用与借用

如何定义并使用一个（新的）calculate_length 函数，它以一个对象的引用作为参数而不是获取值的所有权：

```rust
fn main() {
  let s1 = String::from("hello");

  //&s1 语法让我们创建一个 指向 值 s1 的引用，但是并不拥有它。因为并不拥有这个值，当引用离开作用域时其指向的值也不会被丢弃。
  let len = calculate_length(&s1);

  println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
  s.len()
} // 这里，s 离开了作用域。但因为它并不拥有引用值的所有权，
  // 所以什么也不会发生

//变量 s 有效的作用域与函数参数的作用域一样，不过当引用离开作用域后并不丢弃它指向的数据，因为我们没有所有权。当函数使用引用而不是实际值作为参数，无需返回值来交还所有权，因为就不曾拥有所有权。

//首先，注意变量声明和函数返回值中的所有元组代码都消失了。
//其次，注意我们传递 &s1 给 calculate_length，
//同时在函数定义中，我们获取 &String 而不是 String。

//这些 & 符号就是 引用，它们允许你使用值但不获取其所有权。
```

注意：与使用 & 引用相反的操作是 解引用（dereferencing），它使用解引用运算符，\*。

我们将获取引用作为函数参数称为 **借用（borrowing）**。正如现实生活中，如果一个人拥有某样东西，你可以从他那里借来。当你使用完毕，必须还回去。

如果我们尝试修改借用的变量呢？尝试示例 4-6 中的代码。剧透：这行不通！

正如变量默认是不可变的，引用也一样。（默认）不允许修改引用的值。

- 可变引用

```rust
fn main() {
  let mut s = String::from("hello");

  change(&mut s);
}

fn change(some_string: &mut String) {
  some_string.push_str(", world");
}
//首先，必须将 s 改为 mut。然后必须创建一个可变引用 &mut s 和接受一个可变引用 some_string: &mut String。
```

不过可变引用有一个很大的限制：在特定作用域中的特定数据有且只有一个可变引用。

这个限制允许可变性，不过是以一种受限制的方式允许。新 Rustacean 们经常与此作斗争，因为大部分语言中变量任何时候都是可变的。

这个限制的好处是 Rust 可以在编译时就避免数据竞争。数据竞争（data race）类似于竞态条件，它可由这三个行为造成：

两个或更多指针同时访问同一数据。
至少有一个指针被用来写入数据。
没有同步数据访问的机制。
数据竞争会导致未定义行为，难以在运行时追踪，并且难以诊断和修复；Rust 避免了这种情况的发生，因为它甚至不会编译存在数据竞争的代码！

一如既往，可以使用大括号来创建一个新的作用域，以允许拥有多个可变引用，只是不能 同时 拥有：

```rust
let mut s = String::from("hello");

{
  let r1 = &mut s;
} // r1 在这里离开了作用域，所以我们完全可以创建一个新的引用

let r2 = &mut s;
```

我们 也 不能在拥有不可变引用的同时拥有可变引用。不可变引用的用户可不希望在他们的眼皮底下值就被意外的改变了！然而，多个不可变引用是可以的，因为没有哪个只能读取数据的人有能力影响其他人读取到的数据。

尽管这些错误有时使人沮丧，但请牢记这是 Rust 编译器在提前指出一个潜在的 bug（在编译时而不是在运行时）并精准显示问题所在。这样你就不必去跟踪为何数据并不是你想象中的那样。

- 悬垂引用(Dangling References)

在具有指针的语言中，很容易通过释放内存时保留指向它的指针而错误地生成一个 悬垂指针（dangling pointer），所谓悬垂指针是其指向的内存可能已经被分配给其它持有者。相比之下，**在 Rust 中编译器确保引用永远也不会变成悬垂状态**：当你拥有一些数据的引用，编译器确保数据不会在其引用之前离开作用域。

```rust
fn main() {
    let reference_to_nothing = dangle();
}

// error
fn dangle() -> &String { // dangle 返回一个字符串的引用

    let s = String::from("hello"); // s 是一个新字符串

    &s // 返回字符串 s 的引用
} // 这里 s 离开作用域并被丢弃。其内存被释放。
  // 危险！

// 解决方法是直接返回 String:
fn no_dangle() -> String {
    let s = String::from("hello");

    s
}

//这样就没有任何错误了。所有权被移动出去，所以没有值被释放
```

**引用的规则**.
让我们概括一下之前对引用的讨论：

- 在任意给定时间，要么 只能有一个可变引用，要么 只能有多个不可变引用。
- 引用必须总是有效。

接下来，我们来看看另一种不同类型的引用：slice。

- Slice 类型

另一个没有所有权的数据类型是 slice。slice 允许你引用集合中一段连续的元素序列，而不用引用整个集合。

```rust
//编写一个函数，该函数接收一个字符串，并返回在该字符串中找到的第一个单词。如果函数在该字符串中并未找到空格，则整个字符串就是一个单词，所以应该返回整个字符串。
fn first_word(s: &String) -> usize {
  let bytes = s.as_bytes();

  for(i, &item) in bytes.iter().enumerate() {
    if item === b' ' {
      return i
    }
  }

  s.len()
}

fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s); // word 的值为 5

    s.clear(); // 这清空了字符串，使其等于 ""

    // word 在此处的值仍然是 5，
    // 但是没有更多的字符串让我们可以有效地应用数值 5。word 的值现在完全无效！
}
```

幸运的是，Rust 为这个问题提供了一个解决方法：字符串 slice。

```rust
let s = String::from("hello world");

let hello = &s[0..5];
let world = &s[6..11];

//start..end 语法代表一个以 start 开头并一直持续到但不包含 end 的 range。如果需要包含 end，可以使用 ..= 而不是 ..：

let hello = &s[0..=4];
let world = &s[6..=10];
```

= 意味着包含最后的数字，这有助于你记住 .. 与 ..= 的区别

对于 Rust 的 .. range 语法，如果想要从第一个索引（0）开始，可以不写两个点号之前的值。

由此类推，如果 slice 包含 String 的最后一个字节，也可以舍弃尾部的数字。

在记住所有这些知识后，让我们重写 first_word 来返回一个 slice。“字符串 slice” 的类型声明写作 &str：

```rust
fn first_word(s: &String) -> &str {
  let bytes = s.as_bytes();

  for(i, &item) in bytes.iter().enumerate() {
    if item == b' ' {
      return &s[0, i];
    }

    &s[..]
  }
}
```

现在当调用 first_word 时，会返回与底层数据关联的单个值。这个值由一个 slice 开始位置的引用和 slice 中元素的数量组成。

回忆一下借用规则，当拥有某值的不可变引用时，就不能再获取一个可变引用。因为 clear 需要清空 String，它尝试获取一个可变引用，它失败了。Rust 不仅使得我们的 API 简单易用，也在编译时就消除了一整类的错误！

字符串字面值就是 slice
还记得我们讲到过字符串字面值被储存在二进制文件中吗。现在知道 slice 了，我们就可以正确的理解字符串字面值了：

`let s = "Hello, world!";`
这里 s 的类型是 &str：它是一个指向二进制程序特定位置的 slice。这也就是为什么字符串字面值是不可变的；&str 是一个不可变引用

而更有经验的 Rustacean 会编写出示例 4-9 中的签名，因为它使得可以对 String 值和 &str 值使用相同的函数：

`fn first_word(s: &str) -> &str {`

如果有一个字符串 slice，可以直接传递它。如果有一个 String，则可以传递整个 String 的 slice。定义一个获取字符串 slice 而不是 String 引用的函数使得我们的 API 更加通用并且不会丢失任何功能：

其他类型的 slice

字符串 slice，正如你想象的那样，是针对字符串的。不过也有更通用的 slice 类型。考虑一下这个数组：

`let a = [1, 2, 3, 4, 5];`
就跟我们想要获取字符串的一部分那样，我们也会想要引用数组的一部分。我们可以这样做：

`let a = [1, 2, 3, 4, 5];`

`let slice = &a[1..3];`

总结:
所有权、借用和 slice 这些概念让 Rust 程序在编译时确保内存安全。Rust 语言提供了跟其他系统编程语言相同的方式来控制你使用的内存，但拥有数据所有者在离开作用域后自动清除其数据的功能意味着你无须额外编写和调试相关的控制代码。

所有权系统影响了 Rust 中很多其他部分的工作方式，所以我们还会继续讲到这些概念，这将贯穿本书的余下内容。让我们开始第五章，来看看如何将多份数据组合进一个 struct 中。
