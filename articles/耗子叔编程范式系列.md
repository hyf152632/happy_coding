# 编程范式

编程语言发展到今天，出现了好多不同的代码编写范式，但不同的方式解决的都是同一个问题，那就是如何写出更为通用，更具可重用性的代码或模块。

无论传统世界，还是编程世界，我们都在干一件事情。那就是通过使用一种更为通用的方式，用另外的话说就是抽象和隔离，让复杂的“世界”变得简单一些。

然而，要做到抽象，对于 C 语言这样的类型语言来说，首先要拿出来讲的就是抽象类型，这就是所谓的泛型编程。

总体来说， C 语言设计目标是提供一种能以简易的方式编译，处理底层内存，产生少量的机器码以及不需要任何运行环境支持便能运行的编程语言。C 语言也很适合搭配汇编语言来使用。 C 语言把非常底层的控制权交给了程序员，它的设计理念是：

- 相信程序员
- 不会阻止程序员做任何底层的事
- 保持语言的最小和最简的特性
- 保证 C 语言的最快的运行速度，哪怕牺牲移植性

类型系统和泛型的本质

“类型”有时候是一个有用的事，有时候又是一件很讨厌的事情。因为类型是对底层内存布局的一个抽象，会让我们的代码要关注于这些非业务逻辑上的东西。而且，我们的代码需要在不同类型的数据间做处理。但是如果程序语言类型检查得过于严格，那么，我们写出来的代码就不能那么随意。

在动态类型语言的代码中可以看到大量类似 typeof 这样的类型检查代码。是的，这是动态类型带来的另一个问题，就是运行时识别。

如果你用过一段时间的动态类型语言，一旦代码量比较大了，我们就会发现，代码中出现“类型问题”而引发整个程序出错的情况实在是太多太多了。而且，这样的错误会让整个程序崩溃掉。这个时候，我们就很希望提前发现这些类型的问题。

静态语言的支持者会说编译器能帮我们找到这些问题，而动态语言的支持者则认为，静态语言的编译器也无法找到所有的问题，想真正提前找到问题只能通过测试来解决。

泛型的本质
要了解泛型的本质，就需要了解类型的本质：

- 类型是对内存的一种抽象。不同的类型，会有不同的内存布局和内存分配的策略。
- 不同的类型，有不同的操作。所以，对于特定的类型，也有特定的一组操作。

所以，要做到泛型，我们需要做下面的事情：

- 标准化掉类型的内存分配，释放和访问
- 标准化掉类型的操作。比如：比较操作，I/O 操作，复制操作。。。
- 标准化掉数据容器的操作。比如：查找算法，过滤算法，聚合算法。。。
  标准化掉类型上的特有的操作。需要有标准化的接口来回调不同类型的具体操作。。。。

所以，C++ 动用了非常繁多和复杂的技术来达到泛型编程的目标。

泛型的本质就是————屏蔽掉数据和操作数据的细节，让算法更为通用，让编程者更多地关注算法的结构，而不是在算法中处理不同的数据类型。

在编程语言中，类型系统的出现主要是对容许混乱的操作加上了严格的限制，以避免代码以无效的数据使用方式编译或运行。例如，整数运算不可用于字符串；指针的操作不可用于整数上，等等。但是，类型的产生和限制，虽然对底层代码来说是安全的，但是对于更高层次的抽象产生了写负面因素。比如在 C++ 语言里，为了同时满足静态类型和抽象，就导致了模板技术的出现，带来了语言的复杂性。
我们需要清楚地明白，编程语言本质上帮助程序员屏蔽底层机器代码的实现，而让我们可以更为关注业务逻辑代码。但是因为，编程语言作为机器代码和业务逻辑的粘合层，是在让程序员可以控制更多底层的灵活性，还是屏蔽底层细节，让程序员可以更多地关注于业务逻辑，这是很难两全需要 trad-off 的事。
所以，不同的语言在设计上都会做相应的取舍，比如： C 语言偏向于让程序员可以控制更多的底层细节，而 Java 和 Python 则让程序员更多地关注业务功能的实现。而 C ++ 则是两者都想要，导致语言在设计上非常复杂。

在程序世界中，编程工作更多地是解决业务上的问题，而不是计算机的问题，我们需要更为贴近业务，更为抽象的语言，如典型的面向对象语言 C++ 和 Java 等。

C++ 很大程度上解决了 C 语言中的各种问题和不便，尤其是通过类，模板，虚函数和运行时识别等解决了 C 语言的泛型编程问题。然而，如何做更为抽象的泛型呢？答案就是函数式编程(Functional Programming)

相对于计算机的历史而言，函数式编程其实是一个非常古老的概念。函数式编程的基础模型来源于 lamda 演算，而 lamda 演算并没有被设计在计算机上执行。它是一套用于研究函数定义，函数应用和递归的形式系统。

Booleans, integers,(and other data structures) can be entirely replaced by functions!

对于函数式编程来说，它只关心定义输入数据和输出数据相关的关系，数学表达式里面其实是在做一种映射(mapping), 输入的数据和输出的数据关系是什么样的，使用函数来定义的。

函数式编程的特点：
stateless: 函数不维护任何状态。函数式编程的核心精神是 stateless, 简而言之就是它不能存在状态，打个比方，你给我数据我处理完扔出来。里面的数据是不变的
immutable: 输入数据是不能动的，懂了输入数据就有危险，所以要返回新的数据集。

面向对象的编程有三大特点： 封装，继承和多态。

面向对象编程是一种具有对象概念的程序编程范型，同时也是一种程序开发的抽象反正，它可能包含数据，属性，代码与方法。对象则指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的可重用性，灵活性和可扩展性，对象里的程序可以访问及修改对象相关联的数据。在面向对象编程里，计算机程序会被设计成彼此相关的对象。

和函数式编程来比较，函数式强调动词，而面向对象强调名词，面向对象更多的关注接口间的关系，而通过多态来适配不同的具体实现。

编程的本质

Programs = Algorithms + Data Structures
Algorithms = Logic + Control

Programs = Logic + Control + Data Structures

前面讲了这么多的编程范式，或是程序设计的方法。其实，我们都是在围绕着这三件事做的。
比如：

- 就像函数式编程中的 Map/Reduce/Filter, 它们都是一种控制。而传给这些控制模块的那个 Lambda 表达式才是我们要解决的问题的逻辑，它们共同组成了一个算法。最后，我们再把数据放在数据结构里进行处理，最终就成了我们的程序
- 就像我们 Go 语言的委托模式的那个 Undo 实例一样。 Undo 这个事是我们想要解决的问题，是 Logic, 但是 Undo 的流程是控制。
- 就像我们面向对象中依赖于接口而不是实现一样，接口是对逻辑的抽象，真正的逻辑放在不同的具体类中，通过多态或是依赖注入这样的控制来完成对数据在不同情况下的不同处理。

如果你再仔细结合我们之前将的各式各样的编程范式来思考上述这些概念的话，你是否会觉得，所有的语言或编程范式都在解决上面的这些问题。也就是下面的这几个事。

- Control 是可以标准化的。比如：遍历数据，查找数据，多线程，并发，异步等，都是可以标准化的
- 因为 Control 需要处理数据，所以标准化 Control, 需要标准化 Data Structure, 我们可以通过泛型编程来解决这个事
- 而 Control 还要处理用户的业务逻辑，即 Logic. 所以，我们可以通过标准化接口 / 协议来实现，我们的 Control 模式可以适配于任何的逻辑。

上述三点，就是编程范式的本质

**有效地分离 Logic, Control 和 Data 是写出好程序的关键所在！**

我们在写代码当中，就会看到好多这种代码，会把控制逻辑和业务逻辑放在一块。里面有些变量和流程是跟业务相关的，有些是不相关的。业务逻辑决定了程序的复杂度，业务逻辑本身就复杂，你的代码就不可能写得简单。

Logic, 它是程序复杂度的下限，然后，我们为了控制程序，需要再搞出很多控制代码，于是 Logic + Control 的相互交织成为了最终的程序复杂度。

示例：
一段检查用户表单信息的常见代码。

```js
// before
// Logic 和 Control 混在一起
function check_form_x() {
  var name = $('#name').val()
  if (name == name || name.length <= 3) {
    return { status: 1, message: 'Invalid name' }
  }
  var password = $('#password').val()
  if (password == null || password.length <= 8) {
    return { status: 2, message: 'Invalid password' }
  }
  var repeat_password = $('#repeat_password').val()
  if (repeat_password == null || repeat_password.length <= 8) {
    return { status: 3, message: 'Invalid repeat_password' }
  }
  var email = $('#email').val()
  if (!check_email_format(email)) {
    return { status: 4, message: 'Invalid email' }
  }
  //...
  return { status: 0, message: 'OK' }
}

// after
// 做一个 DSL + 一个 DSL 的解析器
var meta_create_user = {
  form_id: 'create_user',
  fields: [
    { id: 'name', type: 'text', min_length: 3 },
    { id: 'password', type: 'password', min_length: 8 },
    { id: 'repeat_password', type: 'password', min_length: 8 },
    { id: 'email', type: 'email' }
  ]
}

var r = check_form(meta_create_user)
```

代码复杂度的原因：

- 业务逻辑的复杂度决定了代码的复杂度；
- 控制逻辑的复杂度 + 业务逻辑的复杂度 ===> 程序代码的混乱不堪
- 绝大多数程序复杂混乱的根本原因：业务逻辑与控制逻辑的耦合

如何分离 control 和 logic ? 我们可以使用下面的这些技术来解耦。

- State Machine
  - 状态定义
  - 状态变迁条件
  - 状态的 action
- DSL -- Domain Specific Language
  - HTML, SQL, Unix Shell Script, AWK, 正则表达式....
- 编程范式
  - 面向对象： 委托，策略，桥接，修饰， loC/DIP, MVC....
  - 函数式编程： 修饰，管道，拼装
  - 逻辑推导式编程： Prolog

这就是**编程的本质**：

- Logic 部分才是真正有意义的(What)
- Control 部分只是影响 Logic 部分的效率(How)
