# 可移植性

有 时 语 言 根 本 没 有 经 过 标 准 化 。 C 语 言 正 式 的 A N S I / I S O 标准在 1 9 8 8 年 颁 布 ， 而 I S O 的 C + + 的标准直到 1 9 9 8 年 才 被 批 准 ， 在 我 们 写 这 些 的 时 候 ， 还 没 有 一 个 在 用 的 编 译 系 统 支 持 这 个 正 式标准。 J a v a 是 更 新 一 些 的 语 言 ， 与 标 准 化 的 距 离 还 有 许 多 年 。 一 个 语 言 标 准 的 开 发 通 常 总 是要等到这个语言已经有了许多不同的、互相冲突的实现，有了进行统一的需求的时候;此 外，它也必须已经被广泛使用，值得付出标准化的代价。在这期间，还是有许多程序需要写， 有许多环境需要支持。

综上所述，虽然在给人的印象上，参考手册和标准是一种严格规范，但它们从来也不能 完全地定义一个语言。这样，由不同实现给出的就可能都是合法的，但却又是互不相容的解 释。有时甚至实现中还存在错误。

可移植代码是一个非常值得去追求的理想，因为有如此多的时间被浪费在修改程序方面， 无论是把程序从一个系统移到另一个系统，还是为了它本身演化的需要，或是因为它运行的 系统发生了变化，在这些情况下需要设法维持程序的继续运行。当然，可移植性不是随便就 能得到的，它要求实现中的特别注意，也需要开发者具有对所有的潜在目标系统在可移植问 题方面的知识。
我们已经指出了追求可移植性的两种途径，即联合和交集。联合途径相当于为在每个目 标系统上工作而写一个版本，利用条件编译一类的机制，把这些代码尽可能地汇集在一起。 这种途径的缺点很多，它造成过多的代码，而且常常是很多非常复杂的代码。它很难更新， 也很难测试。
交集途径是设法以一种形式写出尽量多的代码，使它能在每种系统上运行而不需要做任 何修改。把无法逃避的系统依赖性封装在独立的源文件里，其作用就像是程序与基础系统之 间的界面。交集方法也有缺点，包括可能存在性能方面，甚至特征方面的损失。但是从长远 的观点看，这种途径的利大于弊。
