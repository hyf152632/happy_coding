# 算法和数据结构

总而言之，只有熟悉了这个领域的工具和技术才能对特殊的问题提供正确解答，只有丰富的经验才能提供坚实的专业性结果。

算法和数据结构的研究是计算机科学的重要基石。这是一个富集优雅技术和复杂数学分析结果的领域。这个领域并不是理论嗜好者们的乐园和游戏的场所：一个好的算法或数据结构可能使某个原来需要用成年累月才能完成的问题在分秒之中得到解决。

如果你正要进入一个新领域去开发程序，那么首先需要弄清楚在这里已经有了什么，以免无谓的把时间浪费在别人早已做好的东西上。

每个程序都要依靠算法可数据结构，但很少有程序依赖于必须发明一批全新的东西。即使是很复杂的程序，比如在编译器或者网络浏览器里，主要的数据结构也是数组，表，树和散列表等等。如果在一个程序里要求某些更精巧的东西，它多半也是基于这些简单东西构造起来的。因此，对大部分程序员而言，所需要的是知道有哪些合适的，可用的算法和数据结构，知道如何在各种可以互相替换的东西之中做出选择。

这里要讲的是一个核桃壳里的故事。实际上基本算法只有屈指可数的几个，它们几乎出现在每个程序中，可能已经被包含在程序库里，这就是基本检索和排序。

1. 检索
   要存储静态的表格数据当然应该用数组。
   检索程序必须知道数组里有多少个元素。对这个问题的一种处理方法是传递一个数组长度参数。
   这里采用的是另一种方法，在数组最后放一个 NULL 作为结束标志。

顺序检索算法，它逐个查看每个数据元素是不是要找的那个。如果数据的数目不多，顺序检索就足够快了。
顺序检索非常简单，但是它的工作量与被检索数据的数目成正比。如果要找的数据并不存在，数据量加倍也会使检索的工作量加倍。这是一种线性关系运行时间是数据规模的线性函数，因此这种检索也被称为线性检索。

对于较大的数组，使用二分检索方法效率将更高些。
为了能做二分检索，表格本身必须是排好序的。
二分检索在每个工作步骤中丢掉一半数据。这样，完成检索需要做的步数相当于对表的长度 n 反复除以 2, 直到最后剩下一个元素时所做的除法次数。忽略舍入后得到的是 log2n.
项目越多，二分检索的优势也就越明显。超过某个界限后（这个界限因实现不同可能有差别）二分检索一定会比线性检索更快。

2. 排序

二分检索只能用在元素已经排好序的数组上。如果需要对某个数据集反复进行检索，先把它排序，然后再用二分检索就会很值得。

最好的排序算法之一是快速排序(quicksort)

快速排序非常快，原因是：一旦知道了某个元素比基准值小，它就不必再与那些大的元素进行比较了。同样，大的元素也不必再与小的做比较。这个性质使快速排序远比简单排序算法（如插入排序和冒泡排序）快得多。因为在简单排序算法中，每个元素都需要与所有其他元素进行比较。

大 O 记法

在这种描述中使用的基本参数是 n, 即问题实例的规模，把复杂性或运行时间表达为 n 的函数。这里的 O 表示量级(order)，比如说， 二分检索是 O(logn).
记法 O(f(n)) 表示当 n 增大时，运行时间至多将以正比于 f(n)的速度增长。

可增长数组

数组是组织数据的最简单方式。所以大部分语言都提供了有效而方便地下标数组，字符串也用字符的数组表示。数组的使用非常简单，它提供对元素的 O(1) 访问，又能很好地使用二分检索和快速排序，空间开销也比较小。
对于固定规模的数据集合，数组甚至可以在编译时构建起来。所以，如果能保证数据不太多，数组就是最佳选择。但事情也有另一面，在数组里维护一组不断变化的数据代价很高。所以，如果元素数量无法预计，或者可能会非常多，选择其他数据结构可能就更合适些。

表

除了数组之外，表（链表）是典型程序里使用最多的数据结构。许多程序设计语言里有系统内部定义的表，有些语言（如 lisp） 就完全是基于这种结构构造起来的。
