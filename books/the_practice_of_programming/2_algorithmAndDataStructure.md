# 算法和数据结构

总而言之，只有熟悉了这个领域的工具和技术才能对特殊的问题提供正确解答，只有丰富的经验才能提供坚实的专业性结果。

算法和数据结构的研究是计算机科学的重要基石。这是一个富集优雅技术和复杂数学分析结果的领域。这个领域并不是理论嗜好者们的乐园和游戏的场所：一个好的算法或数据结构可能使某个原来需要用成年累月才能完成的问题在分秒之中得到解决。

如果你正要进入一个新领域去开发程序，那么首先需要弄清楚在这里已经有了什么，以免无谓的把时间浪费在别人早已做好的东西上。

每个程序都要依靠算法可数据结构，但很少有程序依赖于必须发明一批全新的东西。即使是很复杂的程序，比如在编译器或者网络浏览器里，主要的数据结构也是数组，表，树和散列表等等。如果在一个程序里要求某些更精巧的东西，它多半也是基于这些简单东西构造起来的。因此，对大部分程序员而言，所需要的是知道有哪些合适的，可用的算法和数据结构，知道如何在各种可以互相替换的东西之中做出选择。

这里要讲的是一个核桃壳里的故事。实际上基本算法只有屈指可数的几个，它们几乎出现在每个程序中，可能已经被包含在程序库里，这就是基本检索和排序。

1. 检索
   要存储静态的表格数据当然应该用数组。
   检索程序必须知道数组里有多少个元素。对这个问题的一种处理方法是传递一个数组长度参数。
   这里采用的是另一种方法，在数组最后放一个 NULL 作为结束标志。

顺序检索算法，它逐个查看每个数据元素是不是要找的那个。如果数据的数目不多，顺序检索就足够快了。
顺序检索非常简单，但是它的工作量与被检索数据的数目成正比。如果要找的数据并不存在，数据量加倍也会使检索的工作量加倍。这是一种线性关系运行时间是数据规模的线性函数，因此这种检索也被称为线性检索。

对于较大的数组，使用二分检索方法效率将更高些。
为了能做二分检索，表格本身必须是排好序的。
二分检索在每个工作步骤中丢掉一半数据。这样，完成检索需要做的步数相当于对表的长度 n 反复除以 2, 直到最后剩下一个元素时所做的除法次数。忽略舍入后得到的是 log2n.
项目越多，二分检索的优势也就越明显。超过某个界限后（这个界限因实现不同可能有差别）二分检索一定会比线性检索更快。

2. 排序

二分检索只能用在元素已经排好序的数组上。如果需要对某个数据集反复进行检索，先把它排序，然后再用二分检索就会很值得。

最好的排序算法之一是快速排序(quicksort)

快速排序非常快，原因是：一旦知道了某个元素比基准值小，它就不必再与那些大的元素进行比较了。同样，大的元素也不必再与小的做比较。这个性质使快速排序远比简单排序算法（如插入排序和冒泡排序）快得多。因为在简单排序算法中，每个元素都需要与所有其他元素进行比较。

大 O 记法

在这种描述中使用的基本参数是 n, 即问题实例的规模，把复杂性或运行时间表达为 n 的函数。这里的 O 表示量级(order)，比如说， 二分检索是 O(logn).
记法 O(f(n)) 表示当 n 增大时，运行时间至多将以正比于 f(n)的速度增长。

可增长数组

数组是组织数据的最简单方式。所以大部分语言都提供了有效而方便地下标数组，字符串也用字符的数组表示。数组的使用非常简单，它提供对元素的 O(1) 访问，又能很好地使用二分检索和快速排序，空间开销也比较小。
对于固定规模的数据集合，数组甚至可以在编译时构建起来。所以，如果能保证数据不太多，数组就是最佳选择。但事情也有另一面，在数组里维护一组不断变化的数据代价很高。所以，如果元素数量无法预计，或者可能会非常多，选择其他数据结构可能就更合适些。

表

除了数组之外，表（链表）是典型程序里使用最多的数据结构。许多程序设计语言里有系统内部定义的表，有些语言（如 lisp） 就完全是基于这种结构构造起来的。

一个单链表包含一组项，每个项都包含了有关数据和指向下一个项的指针。表的头就是一个指针，它指向第一个项，而表的结束则用空指针表示。

数组和表之间有一些很重要的差别。
首先，数组具有固定大小，而表则永远具有恰好能容纳其所有内容的大小，在这里每个项都需要一个指针的附加存储开销。
第二，通过修改几个指针，表里的各种情况很容易重新进行安排，与数组里需要做大面积的元素移动相比，修改几个指针的代价要小得多。
最后，当有某些项被插入或者删除时，其他的项都不必移动。如果把指向一些项的指针存入其他数据结构的元素中，表的修改也不会使这些指针变为非法的。

这些情况说明，如果一个数据集合里的项经常变化，特别是如果项的数目无法预计时，表是一种可行的存储它们的方式。经过这些比较，我们容易看到，数组更适合存储相对静态的数据。

对表的一些基本操作：在表的最前面或者最后加入一个新项，检索一个特定项，在某个指定项的前面或者后面加入一个新项，可能还有删除一个项等等。

表特别适合那些需要在中间插入和删除的情况，也适用于管理一批规模经常变动的无序数据，特别是当数据的访问方式接近后进先出（LIFO）的情况时（类似于栈）。

树

树是一种分层性数据结构。
实际存在许多不同种类的树，它们表示各种复杂的结构。

散列表
散列表是计算机科学里的一个伟大发明，它是由数组，表和一些数学方法相结合，构造起来的一种能够有效支持动态数据的存储和提取的结构。
散列表的一个典型应用是符号表，在一些值（数据）与动态的字符串（关键码）集合的成员间建立一种关联。

散列表的思想就是把关键码送给一个散列函数，产生出一个散列值，这种值平均分布在一个适当的正数区间中。

小结
选择算法有几个步骤。
首先，应参考所有可能的算法和数据结构，考虑程序将要处理的数据大概有多少。如果被处理数据的量不大，那么就选择最简单的技术。如果数据可能增长，请删掉那些不能对付大数据集合的东西。
然后，如果有库或者语言本身的特征可以使用，就应该使用。如果没有，那么就写或者借用一个短的，简单的和容易理解的实现。如果实际测试说明它太慢，那么就需要改用某种更高级的技术。
虽然实际存在许多不同的数据结构，某些结构在一些特殊环境中达到较高性能是至关重要的，但是一般程序员主要使用的仍然是数组，链表，树和散列表。这些结构中的每一个都支持一组基本操作，通常包括建立新元素，寻找一个元素，在某处增加一个元素，或者还有删除一个元素，以及把某个操作作用于所有的元素，等等。
各种操作都具有一定的期望计算时间，这常常决定了一个数据结构（一个实现）是否适于某种特定应用。数组支持在常数时间里访问任何元素，但不能方便地增长或缩短。链表对于插入，删除可以很好地适应，但对它做随机元素访问要求 O（n）的时间。树与散列表提供了好的折中，既支持对特定元素的快速访问，又支持方便的增长，条件是只要能维持好某种平衡性。
对于某些特殊问题，还存在一些更复杂的数据结构。但是，上面这个基本集合对构造绝大部分软件而言，已经完全够用了。
