# 测试

测试和排错常常被说成是一个阶段，实际上它们根本不是同一件事。简单地说，排错是 在你已经知道程序有问题时要做的事情。而测试则是在你在认为程序能工作的情况下，为设 法打败它而进行的一整套确定的系统化的试验。

产生无错误代码的一个途径是用程序来生成代码。如果某些程序的工作已经彻底理解清 楚了，写代码的方式很机械，那么就应该把它机械化。用某种特定语言描述后，程序可以自 动生成出来，这种情况也是很常见的。典型的例子如:我们把高级语言的程序编译成汇编代 码;使用正则表达式来描述正文的模式;我们使用 S U M ( A 1 : A 5 0 ) 一 类 的 记 法 ， 表 示 的 是 在 电子表格系统中一系列单元上的运算。

问题当然是发现得越早越好。如果你在写代码时就系统地考虑了应该写什么，那么也可 以在程序构造过程中验证它的简单性质。这样做的结果是，甚至代码还没有经过编译，就已 经经过了一轮测试。这样，有些错误类根本就不会出现了。

测试代码的边界情况。

在 1 9 9 8 年 11 月 的 《 科 学 美 国 人 》 杂 志 上 有
一篇文章，描述了美国导弹巡洋舰约克敦号上的一起事故。一个船员错误地输入了一个 0 作为
数据值，结果造成了除零错，这个错误窜了出去，最后关闭了军舰的推进系统。约克敦号 “死”在海上几个小时，就是因为某个程序没有对输入的合法性进行检查。

断言机制对于检验界面性质特别有用，因为它可以使人注意到调用和被调用之间的不一致性， 并可以进一步指出麻烦究竟是出在哪里。

防御性的程序设计。有一种很有用的技术，那就是在程序里增加一些代码，专门处理所有 “不可能”出现的情况，也就是处理那些从逻辑上讲不可能发生，但是或许 (由于其他地方的
某些失误 ) 可 能 出 现 的 情 况 。

在编程的过程中测试，其花费是最小的，而回报却特别优厚。在写程序过程中考虑测试 问题，得到的将是更好的代码，因为在这时你对代码应该做些什么了解得最清楚。如果不这 样做，而是一直等到某种东西崩溃了，到那时你可能已经忘记了代码是怎样工作的。即使是 在强大的工作压力下，你也还必须重新把它弄清楚，这又要花费许多时间。进一步说，这样 做出的更正往往不会那么彻底，可能更脆弱，因为你唤回的理解可能不那么完全。

测试秘诀

有经验的测试者使用许多技术和技巧，以提高自己的工作效率。本节将介绍一些我们最 喜欢的东西。

程序都应该检查数组的界限 (如果语言本身不做这件事的话 )，但是，如果数组本身的大小 比典型输入大得多时，这种检查代码就常常测试不到。

让散列函数返回某个常数值，使所有元素都跑到同一个散列桶里。这种做法能演习链的 机制，它也指明了最坏情况下的性能。

谁来测试

由程序实现者或其他可以接触源代码的人做的测试有时也被称为白箱测试 (这个术语与黑 箱测试类似，但用的没有那么多。叫它“透明箱测试”可能更说明问题。在黑箱测试中测试 者不知道部件的实现方式 )。对自己的代码做测试是非常重要的，不要指望某种测试组织或者 用户可以为你发现什么。但是，人很容易用自己已经非常仔细地做过测试来欺骗自己。

做测试的原因就是要发现程序里的错误，而不 是为了表明这个程序能够工作。所以，测试应该是恶毒的，如果发现了问题，那是你的方法 有效的证明，根本不应该恐慌。

黑箱测试的测试者对代码的内部结构毫不知情，也无法触及。这样就可能发现另一类的 错误，因为做测试的人对该在哪里做检查可能另有一些猜测。边界条件可能是开始做黑箱测 试的好地方，大量的、邪恶的、非法的输入应该是随后的选择。当然你也应该测试常规的“大路货的”东西，测试程序的常规使用，验证其基本功能。

小结

你把开始的代码写得越好，它出现的错误也就越少，你也就越能相信所做过的测试是彻 底的。在写代码的同时测试边界条件，这是去除大量可笑的小错误的最有效方法。系统化测 试以一种有序方式设法探测潜在的麻烦位置。同样，毛病最可能出现在边界，这可以通过手 工的或者程序的方式检查。自动进行测试是最理想的，用得越多越好，因为机器不会犯错误、 不会疲劳、不会用臆想某些实际无法工作的东西能行来欺骗自己。回归测试检查一个程序是 否能产生与它们过去相同的输出。在做了小改变之后就测试是一种好技术，能帮助我们将出 现问题的范围局部化，因为新问题一般就出现在新代码里面。
对于测试，惟一的、最重要的规则就是必须做。
